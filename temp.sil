// Generated on 2021-05-05 at 21:33:02
domain Process {
  
  function p_is_choice(p1: Process, p2: Process): Bool
  
  function p_empty(): Process
  
  function p_merge(p1: Process, p2: Process): Process
  
  function p_choice(p1: Process, p2: Process): Process
  
  function p_seq(p1: Process, p2: Process): Process
  
  function p_total(tid: Int): Process
  
  function p_afterBeginPending(tid: Int): Process
  
  function p_afterReady(tid: Int): Process
  
  function p_afterCommitPending(tid: Int): Process
  
  function p_init(i: Int): Process
  
  function p_begin(tid: Int): Process
  
  function p_beginOk(tid: Int): Process
  
  function p_inv(tid: Int, invOp: Int): Process
  
  function p_resp(tid: Int, respOp: Int): Process
  
  function p_commit(tid: Int): Process
  
  function p_commitOk(tid: Int): Process
  
  function p_cancel(tid: Int): Process
  
  function p_abort(tid: Int): Process
  
  axiom empty_1L {
    (forall p: Process :: { p_merge(p_empty(), p) } p_merge(p_empty(), p) == p)
  }
  
  axiom empty_2L {
    (forall p: Process :: { p_seq(p_empty(), p) } p_seq(p_empty(), p) == p)
  }
  
  axiom empty_2R {
    (forall p: Process :: { p_seq(p, p_empty()) } p_seq(p, p_empty()) == p)
  }
  
  axiom choice_L {
    (forall p1: Process, p2: Process :: { p_is_choice(p_choice(p1, p2), p1) } p_is_choice(p_choice(p1, p2), p1))
  }
  
  axiom choice_R {
    (forall p1: Process, p2: Process :: { p_is_choice(p_choice(p1, p2), p2) } p_is_choice(p_choice(p1, p2), p2))
  }
  
  axiom choice_dist {
    (forall p1: Process, p2: Process, p3: Process :: { p_seq(p_choice(p1, p2), p3) } p_seq(p_choice(p1, p2), p3) == p_choice(p_seq(p1, p3), p_seq(p2, p3)))
  }
  
  axiom seq_assoc {
    (forall p1: Process, p2: Process, p3: Process :: { p_seq(p_seq(p1, p2), p3) } p_seq(p_seq(p1, p2), p3) == p_seq(p1, p_seq(p2, p3)))
  }
  
  axiom total_def_1 {
    (forall tid: Int :: { p_seq(p_seq(p_init(tid), p_begin(tid)), p_afterBeginPending(tid)) } p_seq(p_seq(p_init(tid), p_begin(tid)), p_afterBeginPending(tid)) == p_total(tid))
  }
  
  axiom total_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_total(tid)) } p_seq(p, p_total(tid)) == p_seq(p, p_seq(p_total(tid), p_empty())))
  }
  
  axiom afterBeginPending_def_1 {
    (forall tid: Int :: { p_afterBeginPending(tid) } p_choice(p_abort(tid), p_seq(p_beginOk(tid), p_afterReady(tid))) == p_afterBeginPending(tid))
  }
  
  axiom afterBeginPending_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_afterBeginPending(tid)) } p_seq(p, p_afterBeginPending(tid)) == p_seq(p, p_seq(p_afterBeginPending(tid), p_empty())))
  }
  
  axiom afterReady_def_1 {
    (forall tid: Int :: { p_afterReady(tid) } p_choice(p_choice(p_seq(p_cancel(tid), p_abort(tid)), p_seq(p_inv(tid, 0), p_choice(p_seq(p_resp(tid, 0), p_afterReady(tid)), p_abort(tid)))), p_seq(p_commit(tid), p_afterCommitPending(tid))) == p_afterReady(tid))
  }
  
  axiom afterReady_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_afterReady(tid)) } p_seq(p, p_afterReady(tid)) == p_seq(p, p_seq(p_afterReady(tid), p_empty())))
  }
  
  axiom afterCommitPending_def_1 {
    (forall tid: Int :: { p_afterCommitPending(tid) } p_choice(p_abort(tid), p_commitOk(tid)) == p_afterCommitPending(tid))
  }
  
  axiom afterCommitPending_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_afterCommitPending(tid)) } p_seq(p, p_afterCommitPending(tid)) == p_seq(p, p_seq(p_afterCommitPending(tid), p_empty())))
  }
  
  axiom init_def_2 {
    (forall p: Process, i: Int :: { p_seq(p, p_init(i)) } p_seq(p, p_init(i)) == p_seq(p, p_seq(p_init(i), p_empty())))
  }
  
  axiom begin_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_begin(tid)) } p_seq(p, p_begin(tid)) == p_seq(p, p_seq(p_begin(tid), p_empty())))
  }
  
  axiom beginOk_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_beginOk(tid)) } p_seq(p, p_beginOk(tid)) == p_seq(p, p_seq(p_beginOk(tid), p_empty())))
  }
  
  axiom inv_def_2 {
    (forall p: Process, tid: Int, invOp: Int :: { p_seq(p, p_inv(tid, invOp)) } p_seq(p, p_inv(tid, invOp)) == p_seq(p, p_seq(p_inv(tid, invOp), p_empty())))
  }
  
  axiom resp_def_2 {
    (forall p: Process, tid: Int, respOp: Int :: { p_seq(p, p_resp(tid, respOp)) } p_seq(p, p_resp(tid, respOp)) == p_seq(p, p_seq(p_resp(tid, respOp), p_empty())))
  }
  
  axiom commit_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_commit(tid)) } p_seq(p, p_commit(tid)) == p_seq(p, p_seq(p_commit(tid), p_empty())))
  }
  
  axiom commitOk_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_commitOk(tid)) } p_seq(p, p_commitOk(tid)) == p_seq(p, p_seq(p_commitOk(tid), p_empty())))
  }
  
  axiom cancel_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_cancel(tid)) } p_seq(p, p_cancel(tid)) == p_seq(p, p_seq(p_cancel(tid), p_empty())))
  }
  
  axiom abort_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_abort(tid)) } p_seq(p, p_abort(tid)) == p_seq(p, p_seq(p_abort(tid), p_empty())))
  }
}

domain TYPE {
  
  unique function class_Future(): TYPE
  
  unique function class_java_DOT_lang_DOT_Object(): TYPE
  
  unique function class_Utils(): TYPE
  
  unique function class_Status(): TYPE
  
  unique function class_Operation(): TYPE
  
  unique function class_TMS1(): TYPE
  
  unique function class_EncodedGlobalVariables(): TYPE
  
  function directSuperclass(t: TYPE): TYPE
  
  function type_of(val: Ref): TYPE
  
  axiom Future_directSuperclass {
    directSuperclass(class_Future()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom Utils_directSuperclass {
    directSuperclass(class_Utils()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom Status_directSuperclass {
    directSuperclass(class_Status()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom Operation_directSuperclass {
    directSuperclass(class_Operation()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom TMS1_directSuperclass {
    directSuperclass(class_TMS1()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom EncodedGlobalVariables_directSuperclass {
    directSuperclass(class_EncodedGlobalVariables()) == class_java_DOT_lang_DOT_Object()
  }
}

domain frac {
  
  function frac_val(a: frac): Perm
  
  axiom frac_eq {
    (forall a: frac, b: frac :: { frac_val(a),frac_val(b) } (frac_val(a) == frac_val(b)) == (a == b))
  }
  
  axiom frac_bound {
    (forall a: frac :: { frac_val(a) } 0 / 1 < frac_val(a) && frac_val(a) <= 1 / 1)
  }
}

domain zfrac {
  
  function zfrac_val(a: zfrac): Perm
  
  axiom zfrac_eq {
    (forall a: zfrac, b: zfrac :: { zfrac_val(a),zfrac_val(b) } (zfrac_val(a) == zfrac_val(b)) == (a == b))
  }
  
  axiom zfrac_bound {
    (forall a: zfrac :: { zfrac_val(a) } 0 / 1 <= zfrac_val(a) && zfrac_val(a) <= 1 / 1)
  }
}

domain VCTTuple[F, S] {
  
  function vcttuple_tuple(f: F, s: S): VCTTuple[F, S]
  
  function vcttuple_fst(t: VCTTuple[F, S]): F
  
  function vcttuple_snd(t: VCTTuple[F, S]): S
  
  axiom vctTupleFstAx {
    (forall f1: F, s1: S :: { (vcttuple_fst((vcttuple_tuple(f1, s1): VCTTuple[F, S])): F) } (vcttuple_fst((vcttuple_tuple(f1, s1): VCTTuple[F, S])): F) == f1)
  }
  
  axiom vctTupleSndAx {
    (forall f1: F, s1: S :: { (vcttuple_snd((vcttuple_tuple(f1, s1): VCTTuple[F, S])): S) } (vcttuple_snd((vcttuple_tuple(f1, s1): VCTTuple[F, S])): S) == s1)
  }
}

//  a field 
field Future_extOrder_hist_value: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_init: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_act: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_write: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_free: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_hist: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_action: Set[VCTTuple[Int, Int]]

//  a field 
field Future_status_hist_value: Seq[Int]

//  a field 
field Future_status_hist_init: Seq[Int]

//  a field 
field Future_status_hist_act: Seq[Int]

//  a field 
field Future_status_hist_write: Seq[Int]

//  a field 
field Future_status_hist_free: Seq[Int]

//  a field 
field Future_status_hist_hist: Seq[Int]

//  a field 
field Future_status_hist_action: Seq[Int]

//  a field 
field Future_ops_hist_value: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_init: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_act: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_write: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_free: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_hist: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_action: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_invokedCommit_hist_value: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_init: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_act: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_write: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_free: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_hist: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_action: Seq[Bool]

//  a field 
field Future_pendingOp_hist_value: Seq[Int]

//  a field 
field Future_pendingOp_hist_init: Seq[Int]

//  a field 
field Future_pendingOp_hist_act: Seq[Int]

//  a field 
field Future_pendingOp_hist_write: Seq[Int]

//  a field 
field Future_pendingOp_hist_free: Seq[Int]

//  a field 
field Future_pendingOp_hist_hist: Seq[Int]

//  a field 
field Future_pendingOp_hist_action: Seq[Int]

function Future_doneTransactions(diz: Ref): Set[Int]
  requires diz != null
  requires acc(diz.Future_status_hist_value, wildcard)
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && (diz.Future_status_hist_value[tid] == Status_committed() || diz.Future_status_hist_value[tid] == Status_aborted()) ==> (tid in result))
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && (diz.Future_status_hist_value[tid] != Status_committed() && diz.Future_status_hist_value[tid] != Status_aborted()) ==> !((tid in result)))
{
  TMS1_doneTransactions_Sequence$Integer$(diz.Future_status_hist_value)
}

function Future_committedTransactions(diz: Ref): Set[Int]
  requires diz != null
  requires acc(diz.Future_status_hist_value, wildcard)
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && diz.Future_status_hist_value[tid] == Status_committed() ==> (tid in result))
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && diz.Future_status_hist_value[tid] != Status_committed() ==> !((tid in result)))
{
  TMS1_committedTransactions_Sequence$Integer$(diz.Future_status_hist_value)
}

function Future_commitPendingTransactions(diz: Ref): Set[Int]
  requires diz != null
  requires acc(diz.Future_status_hist_value, wildcard)
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && diz.Future_status_hist_value[tid] == Status_commitPending() ==> (tid in result))
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && diz.Future_status_hist_value[tid] != Status_commitPending() ==> !((tid in result)))
{
  TMS1_commitPendingTransactions_Sequence$Integer$(diz.Future_status_hist_value)
}

function Future_invokedCommitTransactions(diz: Ref): Set[Int]
  requires diz != null
  requires acc(diz.Future_invokedCommit_hist_value, wildcard)
  requires |diz.Future_invokedCommit_hist_value| == TMS1_NUM_TRANSACTIONS()
  ensures (forall tid: Int :: { (tid in result) } (tid in result) ==> 0 <= tid && tid < TMS1_NUM_TRANSACTIONS())
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && diz.Future_invokedCommit_hist_value[tid] ==> (tid in result))
  ensures (forall tid: Int :: 0 <= tid && tid < TMS1_NUM_TRANSACTIONS() && !diz.Future_invokedCommit_hist_value[tid] ==> !((tid in result)))
{
  TMS1_invokedCommitTransactions_Sequence$Boolean$(diz.Future_invokedCommit_hist_value)
}

function Future_allOps_Sequence$Integer$(diz: Ref, serialization: Seq[Int]): Seq[VCTTuple[Int, Int]]
  requires diz != null
  requires acc(diz.Future_ops_hist_value, wildcard)
  requires (forall i: Int :: { serialization[i] } 0 <= i && i < |serialization| ==> 0 <= serialization[i] && serialization[i] < |diz.Future_ops_hist_value|)
{
  (|serialization| == 0 ? Seq[VCTTuple[Int, Int]]() : diz.Future_ops_hist_value[serialization[0]] ++ Future_allOps_Sequence$Integer$(diz, serialization[1..]))
}

function Future_ser_Set$Integer$_Set$Tuple$Integer_Integer$$(diz: Ref, transactions: Set[Int], order: Set[VCTTuple[Int, Int]]): Set[Seq[Int]]
  requires diz != null
  ensures (forall sequenz: Seq[Int] :: { |sequenz| } (sequenz in result) ==> |sequenz| == |transactions|) && (forall sequenz: Seq[Int], i: Int :: (sequenz in result) && (0 <= i && i < |sequenz|) ==> (sequenz[i] in transactions)) && (forall sequenz: Seq[Int], i: Int, j: Int :: (sequenz in result) && (0 <= i && i < |sequenz|) && (0 <= j && j < |sequenz| && j != i) ==> sequenz[i] != sequenz[j]) && (forall sequenz: Seq[Int] :: (sequenz in result) ==> TMS1_respectsOrder_Sequence$Integer$_Set$Tuple$Integer_Integer$$(sequenz, order))
{
  TMS1_serializations_Set$Integer$_Set$Tuple$Integer_Integer$$(transactions, order)
}

function Future_legal_Sequence$Tuple$Integer_Integer$$(diz: Ref, invRespOps: Seq[VCTTuple[Int, Int]]): Bool
  requires diz != null


function Future_extConsPrefix_Set$Integer$(diz: Ref, serialization: Set[Int]): Bool
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, wildcard)
  requires acc(diz.Future_status_hist_value, wildcard)
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires (forall tid: Int :: { (tid in serialization) } (tid in serialization) ==> 0 <= tid && tid < TMS1_NUM_TRANSACTIONS())
{
  (0 < TMS1_NUM_TRANSACTIONS() ==> (forall idTwo: Int :: { (idTwo in serialization) } 0 <= idTwo && idTwo < TMS1_NUM_TRANSACTIONS() ==> (idTwo in serialization))) && (forall idOne: Int, idTwo: Int :: 0 <= idOne && idOne < TMS1_NUM_TRANSACTIONS() && (0 <= idTwo && idTwo < TMS1_NUM_TRANSACTIONS() && TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(idOne, idTwo, diz.Future_extOrder_hist_value)) ==> (idOne in serialization) == (diz.Future_status_hist_value[idOne] == Status_committed()))
}

function Future_validCommit_Integer(diz: Ref, tid: Int): Bool
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, wildcard)
  requires acc(diz.Future_status_hist_value, wildcard)
  requires acc(diz.Future_ops_hist_value, wildcard)
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_ops_hist_value| == TMS1_NUM_TRANSACTIONS()
{
  (exists S: Set[Int] :: (S subset Future_commitPendingTransactions(diz)) && (exists serialization: Seq[Int] :: (serialization in Future_ser_Set$Integer$_Set$Tuple$Integer_Integer$$(diz, (Future_committedTransactions(diz) union S), diz.Future_extOrder_hist_value)) && ((tid in S) && Future_legal_Sequence$Tuple$Integer_Integer$$(diz, Future_allOps_Sequence$Integer$(diz, serialization)))))
}

function Future_validFail_Integer(diz: Ref, tid: Int): Bool
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, wildcard)
  requires acc(diz.Future_status_hist_value, wildcard)
  requires acc(diz.Future_ops_hist_value, wildcard)
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_ops_hist_value| == TMS1_NUM_TRANSACTIONS()
{
  (exists S: Set[Int] :: (S subset Future_commitPendingTransactions(diz)) && (exists serialization: Seq[Int] :: (serialization in Future_ser_Set$Integer$_Set$Tuple$Integer_Integer$$(diz, (Future_committedTransactions(diz) union S), diz.Future_extOrder_hist_value)) && (!((tid in S)) && Future_legal_Sequence$Tuple$Integer_Integer$$(diz, Future_allOps_Sequence$Integer$(diz, serialization)))))
}

function Future_validResp_Integer_Integer_Integer(diz: Ref, tid: Int, pendingOp: Int, respOp: Int): Bool
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, wildcard)
  requires acc(diz.Future_status_hist_value, wildcard)
  requires acc(diz.Future_ops_hist_value, wildcard)
  requires acc(diz.Future_invokedCommit_hist_value, wildcard)
  requires |diz.Future_invokedCommit_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_ops_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires 0 <= tid && tid < TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
{
  (exists S: Set[Int] :: (S subset Future_invokedCommitTransactions(diz)) && (exists serialization: Seq[Int] :: (serialization in Future_ser_Set$Integer$_Set$Tuple$Integer_Integer$$(diz, S, diz.Future_extOrder_hist_value)) && (Future_extConsPrefix_Set$Integer$(diz, (S union Set(tid))) && Future_legal_Sequence$Tuple$Integer_Integer$$(diz, Future_allOps_Sequence$Integer$(diz, serialization ++ Seq(tid)) ++ Seq((vcttuple_tuple(pendingOp, respOp): VCTTuple[Int, Int]))))))
}

function Utils_append_Sequence$Integer$_Integer(list: Seq[Int], item: Int): Seq[Int]
{
  list ++ Seq(item)
}

function Utils_append_Sequence$Tuple$Integer_Integer$$_Tuple$Integer_Integer$(list: Seq[VCTTuple[Int, Int]], item: VCTTuple[Int, Int]): Seq[VCTTuple[Int, Int]]
{
  list ++ Seq(item)
}

function Utils_concat_Sequence$Integer$_Sequence$Integer$(list1: Seq[Int], list2: Seq[Int]): Seq[Int]
{
  list1 ++ list2
}

function Utils_concat_Sequence$Tuple$Integer_Integer$$_Sequence$Tuple$Integer_Integer$$(list1: Seq[VCTTuple[Int, Int]], list2: Seq[VCTTuple[Int, Int]]): Seq[VCTTuple[Int, Int]]
{
  list1 ++ list2
}

function Utils_flatten_Set$Set$Integer$$(theSet: Set[Set[Int]]): Set[Int]
  ensures (forall aSet: Set[Int], x: Int :: (aSet in theSet) && (x in aSet) ==> (x in result))
  ensures (forall x: Int :: (x in result) ==> (exists aSet: Set[Int] :: (aSet in theSet) && (x in aSet)))


function Status_notStarted(): Int
{
  0
}

function Status_beginPending(): Int
{
  1
}

function Status_ready(): Int
{
  2
}

function Status_opPending(): Int
{
  3
}

function Status_commitPending(): Int
{
  4
}

function Status_cancelPending(): Int
{
  5
}

function Status_committed(): Int
{
  6
}

function Status_aborted(): Int
{
  7
}

function Operation_encodeInvokeWrite_Integer_Integer(address: Int, value: Int): Int
{
  4 * (2 * address + 1 + 2 * value)
}

function Operation_encodeInvokeRead_Integer(address: Int): Int
{
  1 + 4 * (2 * address)
}

function Operation_encodeResponseRead_Integer_Integer(address: Int, value: Int): Int
{
  2 + 4 * (2 * address + 1 + 2 * value)
}

function Operation_encodeResponseWrite_Integer(address: Int): Int
{
  3 + 4 * (2 * address)
}

function TMS1_NUM_TRANSACTIONS(): Int
{
  10
}

function TMS1_doneTransactions_Sequence$Integer$(statuses: Seq[Int]): Set[Int]
  requires |statuses| == TMS1_NUM_TRANSACTIONS()
  ensures |statuses| == TMS1_NUM_TRANSACTIONS()
  ensures (forall i: Int :: 0 <= i && i < |statuses| && (statuses[i] == Status_committed() || statuses[i] == Status_aborted()) ==> (i in result))
  ensures (forall i: Int :: 0 <= i && i < |statuses| && (statuses[i] != Status_committed() && statuses[i] != Status_aborted()) ==> !((i in result)))
{
  TMS1_doneTransactionsHelper_Integer_Sequence$Integer$(0, statuses)
}

function TMS1_doneTransactionsHelper_Integer_Sequence$Integer$(currentIndex: Int, statuses: Seq[Int]): Set[Int]
  requires |statuses| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |statuses| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |result| <= |statuses|
  ensures (forall i: Int :: { (i in result) } (i in result) ==> currentIndex <= i && i < currentIndex + |statuses|)
  ensures (forall i: Int :: { statuses[i] } 0 <= i && i < |statuses| && (statuses[i] == Status_committed() || statuses[i] == Status_aborted()) ==> (currentIndex + i in result))
  ensures (forall i: Int :: { statuses[i] } 0 <= i && i < |statuses| && (statuses[i] != Status_committed() && statuses[i] != Status_aborted()) ==> !((currentIndex + i in result)))
{
  (|statuses| == 0 ? Set[Int]() : ((statuses[0] == Status_committed() || statuses[0] == Status_aborted() ? Set(currentIndex) : Set[Int]()) union TMS1_doneTransactionsHelper_Integer_Sequence$Integer$(currentIndex + 1, statuses[1..])))
}

function TMS1_committedTransactions_Sequence$Integer$(statuses: Seq[Int]): Set[Int]
  requires |statuses| == TMS1_NUM_TRANSACTIONS()
  ensures |statuses| == TMS1_NUM_TRANSACTIONS()
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && statuses[i] == Status_committed() ==> (i in result))
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && statuses[i] != Status_committed() ==> !((i in result)))
{
  TMS1_committedTransactionsHelper_Integer_Sequence$Integer$(0, statuses)
}

function TMS1_committedTransactionsHelper_Integer_Sequence$Integer$(currentIndex: Int, statuses: Seq[Int]): Set[Int]
  requires |statuses| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |statuses| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |result| <= |statuses|
  ensures (forall i: Int :: { (i in result) } (i in result) ==> currentIndex <= i && i < currentIndex + |statuses|)
  ensures (forall i: Int :: { statuses[i] } 0 <= i && i < |statuses| && statuses[i] == Status_committed() ==> (currentIndex + i in result))
  ensures (forall i: Int :: { statuses[i] } 0 <= i && i < |statuses| && statuses[i] != Status_committed() ==> !((currentIndex + i in result)))
{
  (|statuses| == 0 ? Set[Int]() : ((statuses[0] == Status_committed() ? Set(currentIndex) : Set[Int]()) union TMS1_committedTransactionsHelper_Integer_Sequence$Integer$(currentIndex + 1, statuses[1..])))
}

function TMS1_commitPendingTransactions_Sequence$Integer$(statuses: Seq[Int]): Set[Int]
  requires |statuses| == TMS1_NUM_TRANSACTIONS()
  ensures |statuses| == TMS1_NUM_TRANSACTIONS()
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && statuses[i] == Status_commitPending() ==> (i in result))
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && statuses[i] != Status_commitPending() ==> !((i in result)))
{
  TMS1_commitPendingTransactionsHelper_Integer_Sequence$Integer$(0, statuses)
}

function TMS1_commitPendingTransactionsHelper_Integer_Sequence$Integer$(currentIndex: Int, statuses: Seq[Int]): Set[Int]
  requires |statuses| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |statuses| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |result| <= |statuses|
  ensures (forall i: Int :: { (i in result) } (i in result) ==> currentIndex <= i && i < currentIndex + |statuses|)
  ensures (forall i: Int :: { statuses[i] } 0 <= i && i < |statuses| && statuses[i] == Status_commitPending() ==> (currentIndex + i in result))
  ensures (forall i: Int :: { statuses[i] } 0 <= i && i < |statuses| && statuses[i] != Status_commitPending() ==> !((currentIndex + i in result)))
{
  (|statuses| == 0 ? Set[Int]() : ((statuses[0] == Status_commitPending() ? Set(currentIndex) : Set[Int]()) union TMS1_commitPendingTransactionsHelper_Integer_Sequence$Integer$(currentIndex + 1, statuses[1..])))
}

function TMS1_invokedCommitTransactions_Sequence$Boolean$(invokedCommits: Seq[Bool]): Set[Int]
  requires |invokedCommits| == TMS1_NUM_TRANSACTIONS()
  ensures |invokedCommits| == TMS1_NUM_TRANSACTIONS()
  ensures (forall i: Int :: { (i in result) } (i in result) ==> 0 <= i && i < TMS1_NUM_TRANSACTIONS())
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && invokedCommits[i] ==> (i in result))
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && !invokedCommits[i] ==> !((i in result)))
{
  TMS1_invokedCommitTransactionsHelper_Integer_Sequence$Boolean$(0, invokedCommits)
}

function TMS1_invokedCommitTransactionsHelper_Integer_Sequence$Boolean$(currentIndex: Int, invokedCommits: Seq[Bool]): Set[Int]
  requires |invokedCommits| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |invokedCommits| == TMS1_NUM_TRANSACTIONS() - currentIndex
  ensures |result| <= |invokedCommits|
  ensures (forall i: Int :: { (i in result) } (i in result) ==> currentIndex <= i && i < currentIndex + |invokedCommits|)
  ensures (forall i: Int :: { invokedCommits[i] } 0 <= i && i < |invokedCommits| && invokedCommits[i] ==> (currentIndex + i in result))
  ensures (forall i: Int :: { invokedCommits[i] } 0 <= i && i < |invokedCommits| && !invokedCommits[i] ==> !((currentIndex + i in result)))
{
  (|invokedCommits| == 0 ? Set[Int]() : ((invokedCommits[0] ? Set(currentIndex) : Set[Int]()) union TMS1_invokedCommitTransactionsHelper_Integer_Sequence$Boolean$(currentIndex + 1, invokedCommits[1..])))
}

function TMS1_serializations_Set$Integer$_Set$Tuple$Integer_Integer$$(transactions: Set[Int], externalOrder: Set[VCTTuple[Int, Int]]): Set[Seq[Int]]
  ensures (forall sequenz: Seq[Int] :: { |sequenz| } (sequenz in result) ==> |sequenz| == |transactions|) && (forall sequenz: Seq[Int], i: Int :: (sequenz in result) && (0 <= i && i < |sequenz|) ==> (sequenz[i] in transactions)) && (forall sequenz: Seq[Int], i: Int, j: Int :: (sequenz in result) && (0 <= i && i < |sequenz|) && (0 <= j && j < |sequenz| && j != i) ==> sequenz[i] != sequenz[j]) && (forall sequenz: Seq[Int] :: (sequenz in result) ==> TMS1_respectsOrder_Sequence$Integer$_Set$Tuple$Integer_Integer$$(sequenz, externalOrder))


function TMS1_respectsOrder_Sequence$Integer$_Set$Tuple$Integer_Integer$$(transactionIds: Seq[Int], order: Set[VCTTuple[Int, Int]]): Bool
  ensures result == (forall index: Int :: { transactionIds[index] } 0 <= index && index < |transactionIds| - 1 ==> TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(transactionIds[index], transactionIds[index + 1], order))
{
  (forall index: Int :: { transactionIds[index] } 0 <= index && index < |transactionIds| - 1 ==> TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(transactionIds[index], transactionIds[index + 1], order))
}

function TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(left: Int, right: Int, order: Set[VCTTuple[Int, Int]]): Bool
  requires TMS1_acyclic_Set$Tuple$Integer_Integer$$(order)
{
  ((vcttuple_tuple(left, right): VCTTuple[Int, Int]) in order) || (exists newRight: Int :: (newRight in TMS1_rightValues2_Integer_Set$Tuple$Integer_Integer$$(left, order)) && TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(newRight, right, order))
}

function TMS1_rightValues2_Integer_Set$Tuple$Integer_Integer$$(leftValue: Int, relation: Set[VCTTuple[Int, Int]]): Set[Int]
  ensures (forall right: Int :: (right in result) ==> ((vcttuple_tuple(leftValue, right): VCTTuple[Int, Int]) in relation))
  ensures (forall tup: VCTTuple[Int, Int] :: (tup in relation) && (vcttuple_fst(tup): Int) == leftValue ==> ((vcttuple_snd(tup): Int) in result))


function TMS1_rightValues_Integer_Set$Tuple$Integer_Integer$$(leftValue: Int, relation: Set[VCTTuple[Int, Int]]): Set[Int]
  ensures (forall i: Int :: { (i in result) } (i in result) ==> 0 <= i && i < TMS1_NUM_TRANSACTIONS())
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && ((vcttuple_tuple(leftValue, i): VCTTuple[Int, Int]) in relation) ==> (i in result))
  ensures (forall i: Int :: 0 <= i && i < TMS1_NUM_TRANSACTIONS() && !(((vcttuple_tuple(leftValue, i): VCTTuple[Int, Int]) in relation)) ==> !((i in result)))
{
  TMS1_rightValuesBounded_Integer_Integer_Integer_Set$Tuple$Integer_Integer$$(0, TMS1_NUM_TRANSACTIONS(), leftValue, relation)
}

function TMS1_rightValuesBounded_Integer_Integer_Integer_Set$Tuple$Integer_Integer$$(lowerBoundIncl: Int, upperBoundExcl: Int, leftValue: Int, relation: Set[VCTTuple[Int, Int]]): Set[Int]
  requires 0 <= lowerBoundIncl
  requires lowerBoundIncl <= upperBoundExcl
  ensures (forall i: Int :: { (i in result) } (i in result) ==> lowerBoundIncl <= i && i < upperBoundExcl)
  ensures (forall i: Int :: lowerBoundIncl <= i && i < upperBoundExcl && ((vcttuple_tuple(leftValue, i): VCTTuple[Int, Int]) in relation) ==> (i in result))
  ensures (forall i: Int :: lowerBoundIncl <= i && i < upperBoundExcl && !(((vcttuple_tuple(leftValue, i): VCTTuple[Int, Int]) in relation)) ==> !((i in result)))
{
  (lowerBoundIncl == upperBoundExcl ? Set[Int]() : ((((vcttuple_tuple(leftValue, lowerBoundIncl): VCTTuple[Int, Int]) in relation) ? Set(lowerBoundIncl) : Set[Int]()) union TMS1_rightValuesBounded_Integer_Integer_Integer_Set$Tuple$Integer_Integer$$(lowerBoundIncl + 1, upperBoundExcl, leftValue, relation)))
}

function TMS1_acyclic_Set$Tuple$Integer_Integer$$(relation: Set[VCTTuple[Int, Int]]): Bool
  ensures result == (forall tup: VCTTuple[Int, Int] :: (tup in relation) ==> !(((vcttuple_fst(tup): Int) in TMS1_collectRightValues_Integer_Set$Tuple$Integer_Integer$$((vcttuple_fst(tup): Int), relation))))
{
  (forall tup: VCTTuple[Int, Int] :: (tup in relation) ==> TMS1_acyclicHelper_Tuple$Integer_Integer$_Set$Tuple$Integer_Integer$$(tup, relation))
}

function TMS1_acyclicHelper_Tuple$Integer_Integer$_Set$Tuple$Integer_Integer$$(tup: VCTTuple[Int, Int], relation: Set[VCTTuple[Int, Int]]): Bool
  ensures result != ((vcttuple_fst(tup): Int) in TMS1_collectRightValues_Integer_Set$Tuple$Integer_Integer$$((vcttuple_fst(tup): Int), relation))
{
  !(((vcttuple_fst(tup): Int) in TMS1_collectRightValues_Integer_Set$Tuple$Integer_Integer$$((vcttuple_fst(tup): Int), relation)))
}

function TMS1_collectRightValues_Integer_Set$Tuple$Integer_Integer$$(left: Int, relation: Set[VCTTuple[Int, Int]]): Set[Int]
  ensures (forall right: Int :: (right in result) ==> TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(left, right, relation))
{
  TMS1_collectRightValuesHelper_Set$Tuple$Integer_Integer$$_Set$Integer$(relation, TMS1_rightValues2_Integer_Set$Tuple$Integer_Integer$$(left, relation))
}

function TMS1_collectRightValuesHelper_Set$Tuple$Integer_Integer$$_Set$Integer$(relation: Set[VCTTuple[Int, Int]], accumulator: Set[Int]): Set[Int]
  ensures (forall tup: VCTTuple[Int, Int] :: TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$((vcttuple_fst(tup): Int), (vcttuple_snd(tup): Int), relation) && ((vcttuple_fst(tup): Int) in accumulator) ==> ((vcttuple_snd(tup): Int) in result))
  ensures (forall x: Int, tup: VCTTuple[Int, Int] :: (x in accumulator) && (TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$((vcttuple_fst(tup): Int), (vcttuple_snd(tup): Int), relation) && (vcttuple_fst(tup): Int) == x) ==> ((vcttuple_snd(tup): Int) in result))
  ensures (forall y: Int :: (y in result) ==> (exists x: Int :: (x in accumulator) && TMS1_inOrder_Integer_Integer_Set$Tuple$Integer_Integer$$(x, y, relation)))


function TMS1_allRightValues_Set$Integer$_Set$Tuple$Integer_Integer$$(check: Set[Int], relation: Set[VCTTuple[Int, Int]]): Set[Int]
  ensures (forall right: Int :: (right in result) ==> (exists left: Int :: (left in check) && ((vcttuple_tuple(left, right): VCTTuple[Int, Int]) in relation)))
  ensures (forall left: Int :: (left in check) ==> (exists right: Int :: (right in result) && ((vcttuple_tuple(left, right): VCTTuple[Int, Int]) in relation)))


function TMS1_allRightValuesHelper_Set$Integer$_Set$Tuple$Integer_Integer$$(check: Set[Int], relation: Set[VCTTuple[Int, Int]]): Set[Set[Int]]
  ensures (forall left: Int :: (left in check) ==> (exists rightValues: Set[Int] :: (rightValues in result) && (exists right: Int :: (right in rightValues) && ((vcttuple_tuple(left, right): VCTTuple[Int, Int]) in relation))))
  ensures (forall rightValues: Set[Int] :: (rightValues in result) ==> (exists left: Int :: (left in check) && (exists right: Int :: (right in rightValues) && ((vcttuple_tuple(left, right): VCTTuple[Int, Int]) in relation))))


function instanceof_TYPE_TYPE(t: TYPE, u: TYPE): Bool
  ensures result == (t == u || directSuperclass(t) == u)


function new_frac(x: Perm): frac
  requires 0 / 1 < x && x <= 1 / 1
  ensures frac_val(result) == x


function new_zfrac(x: Perm): zfrac
  requires 0 / 1 <= x && x <= 1 / 1
  ensures zfrac_val(result) == x


predicate Future_hist_do_init_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_begin_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_beginOk_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_inv_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_resp_Fraction_Process_ZFraction_ZFraction_ZFraction(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, pendingOp_frac: zfrac, invokedCommit_frac: zfrac) 

predicate Future_hist_do_commit_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_commitOk_Fraction_Process_ZFraction_ZFraction(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, ops_frac: zfrac) 

predicate Future_hist_do_cancel_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_abort_Fraction_Process_ZFraction_ZFraction(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, ops_frac: zfrac) 

predicate Future_hist_idle_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

method Future_init_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, i: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_init(i), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires write != none
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_hist, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_hist, write)
  requires 0 <= i
  requires i < |diz.Future_status_hist_value|
  requires i < |diz.Future_ops_hist_value|
  requires i < |diz.Future_invokedCommit_hist_value|
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_init_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_act, write)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_action, write)
  ensures diz.Future_ops_hist_value == diz.Future_ops_hist_act
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_act, write)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_action, write)
  ensures diz.Future_invokedCommit_hist_value == diz.Future_invokedCommit_hist_act
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_init_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, i: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_init_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires write != none
  requires acc(diz.Future_ops_hist_act, write)
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_write, write)
  requires acc(diz.Future_ops_hist_action, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_act, write)
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_write, write)
  requires acc(diz.Future_invokedCommit_hist_action, write)
  requires 0 <= i
  requires i < |diz.Future_status_hist_value|
  requires i < |diz.Future_ops_hist_value|
  requires i < |diz.Future_invokedCommit_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_ops_hist_act| == |diz.Future_ops_hist_value|
  requires |diz.Future_invokedCommit_hist_act| == |diz.Future_invokedCommit_hist_value|
  requires diz.Future_status_hist_value[i] == Status_notStarted()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != i ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires diz.Future_ops_hist_value[i] == Seq[VCTTuple[Int, Int]]()
  requires (forall x: Int :: { diz.Future_ops_hist_act[x] } { diz.Future_ops_hist_value[x] } 0 <= x && x < |diz.Future_ops_hist_value| && x != i ==> diz.Future_ops_hist_act[x] == diz.Future_ops_hist_value[x])
  requires diz.Future_invokedCommit_hist_value[i] == false
  requires (forall x: Int :: { diz.Future_invokedCommit_hist_act[x] } { diz.Future_invokedCommit_hist_value[x] } 0 <= x && x < |diz.Future_invokedCommit_hist_value| && x != i ==> diz.Future_invokedCommit_hist_act[x] == diz.Future_invokedCommit_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_hist, write)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_hist, write)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_begin_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_begin(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_notStarted()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_begin_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_begin_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_begin_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_beginPending()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_beginOk_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_beginOk(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_beginPending()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_beginOk_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_beginOk_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_beginOk_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_inv_begin_Fraction_Process_Integer_Integer(diz: Ref, fr: frac, proc: Process, tid: Int, invOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_inv(tid, invOp), proc)), write)
  requires write != none
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_hist, write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_inv_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_pendingOp_hist_act, write)
  ensures acc(diz.Future_pendingOp_hist_value, write)
  ensures acc(diz.Future_pendingOp_hist_write, write)
  ensures acc(diz.Future_pendingOp_hist_action, write)
  ensures diz.Future_pendingOp_hist_value == diz.Future_pendingOp_hist_act
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_inv_commit_Fraction_Process_Integer_Integer(diz: Ref, fr: frac, proc: Process, tid: Int, invOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_inv_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_pendingOp_hist_act, write)
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_write, write)
  requires acc(diz.Future_pendingOp_hist_action, write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_pendingOp_hist_act| == |diz.Future_pendingOp_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_opPending()
  requires diz.Future_pendingOp_hist_value[tid] == invOp
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires (forall x: Int :: { diz.Future_pendingOp_hist_act[x] } { diz.Future_pendingOp_hist_value[x] } 0 <= x && x < |diz.Future_pendingOp_hist_value| && x != tid ==> diz.Future_pendingOp_hist_act[x] == diz.Future_pendingOp_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_pendingOp_hist_value, write)
  ensures acc(diz.Future_pendingOp_hist_hist, write)
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_resp_begin_Fraction_Process_ZFraction_ZFraction_ZFraction_Integer_Integer(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, pendingOp_frac: zfrac, invokedCommit_frac: zfrac, tid: Int, respOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_resp(tid, respOp), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires write != none
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_hist, write)
  requires zfrac_val(extOrder_frac) != none
  requires acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_hist, zfrac_val(extOrder_frac))
  requires zfrac_val(pendingOp_frac) != none
  requires acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_hist, zfrac_val(pendingOp_frac))
  requires zfrac_val(invokedCommit_frac) != none
  requires acc(diz.Future_invokedCommit_hist_value, zfrac_val(invokedCommit_frac))
  requires acc(diz.Future_invokedCommit_hist_hist, zfrac_val(invokedCommit_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_ops_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires |diz.Future_invokedCommit_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_ops_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires Future_validResp_Integer_Integer_Integer(diz, tid, diz.Future_pendingOp_hist_value[tid], respOp)
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_resp_Fraction_Process_ZFraction_ZFraction_ZFraction(diz, fr, proc, extOrder_frac, pendingOp_frac, invokedCommit_frac), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_act, write)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_action, write)
  ensures diz.Future_ops_hist_value == diz.Future_ops_hist_act
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_extOrder_hist_act, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_write, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_action, zfrac_val(extOrder_frac))
  ensures diz.Future_extOrder_hist_value == diz.Future_extOrder_hist_act
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures acc(diz.Future_pendingOp_hist_act, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_write, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_action, zfrac_val(pendingOp_frac))
  ensures diz.Future_pendingOp_hist_value == diz.Future_pendingOp_hist_act
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_act, zfrac_val(invokedCommit_frac))
  ensures acc(diz.Future_invokedCommit_hist_value, zfrac_val(invokedCommit_frac))
  ensures acc(diz.Future_invokedCommit_hist_write, zfrac_val(invokedCommit_frac))
  ensures acc(diz.Future_invokedCommit_hist_action, zfrac_val(invokedCommit_frac))
  ensures diz.Future_invokedCommit_hist_value == diz.Future_invokedCommit_hist_act
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_resp_commit_Fraction_Process_ZFraction_ZFraction_ZFraction_Integer_Integer(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, pendingOp_frac: zfrac, invokedCommit_frac: zfrac, tid: Int, respOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_resp_Fraction_Process_ZFraction_ZFraction_ZFraction(diz, fr, proc, extOrder_frac, pendingOp_frac, invokedCommit_frac), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires write != none
  requires acc(diz.Future_ops_hist_act, write)
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_write, write)
  requires acc(diz.Future_ops_hist_action, write)
  requires zfrac_val(extOrder_frac) != none
  requires acc(diz.Future_extOrder_hist_act, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_write, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_action, zfrac_val(extOrder_frac))
  requires zfrac_val(pendingOp_frac) != none
  requires acc(diz.Future_pendingOp_hist_act, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_write, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_action, zfrac_val(pendingOp_frac))
  requires zfrac_val(invokedCommit_frac) != none
  requires acc(diz.Future_invokedCommit_hist_act, zfrac_val(invokedCommit_frac))
  requires acc(diz.Future_invokedCommit_hist_value, zfrac_val(invokedCommit_frac))
  requires acc(diz.Future_invokedCommit_hist_write, zfrac_val(invokedCommit_frac))
  requires acc(diz.Future_invokedCommit_hist_action, zfrac_val(invokedCommit_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_ops_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_ops_hist_act| == |diz.Future_ops_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  requires diz.Future_ops_hist_value[tid] == Utils_append_Sequence$Tuple$Integer_Integer$$_Tuple$Integer_Integer$(diz.Future_ops_hist_act[tid], (vcttuple_tuple(diz.Future_pendingOp_hist_value[tid], respOp): VCTTuple[Int, Int]))
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires (forall x: Int :: { diz.Future_ops_hist_act[x] } { diz.Future_ops_hist_value[x] } 0 <= x && x < |diz.Future_ops_hist_value| && x != tid ==> diz.Future_ops_hist_act[x] == diz.Future_ops_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_hist, write)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_hist, zfrac_val(extOrder_frac))
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_hist, zfrac_val(pendingOp_frac))
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_value, zfrac_val(invokedCommit_frac))
  ensures acc(diz.Future_invokedCommit_hist_hist, zfrac_val(invokedCommit_frac))
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_commit_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_commit(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_invokedCommit_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_commit_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_act, write)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_action, write)
  ensures diz.Future_invokedCommit_hist_value == diz.Future_invokedCommit_hist_act
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_commit_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_commit_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_act, write)
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_write, write)
  requires acc(diz.Future_invokedCommit_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_invokedCommit_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_invokedCommit_hist_act| == |diz.Future_invokedCommit_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_commitPending()
  requires diz.Future_invokedCommit_hist_value[tid] == true
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires (forall x: Int :: { diz.Future_invokedCommit_hist_act[x] } { diz.Future_invokedCommit_hist_value[x] } 0 <= x && x < |diz.Future_invokedCommit_hist_value| && x != tid ==> diz.Future_invokedCommit_hist_act[x] == diz.Future_invokedCommit_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_hist, write)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_commitOk_begin_Fraction_Process_ZFraction_ZFraction_Integer(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, ops_frac: zfrac, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_commitOk(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires zfrac_val(extOrder_frac) != none
  requires acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_hist, zfrac_val(extOrder_frac))
  requires zfrac_val(ops_frac) != none
  requires acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_hist, zfrac_val(ops_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_commitPending()
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_ops_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires Future_validCommit_Integer(diz, tid)
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_commitOk_Fraction_Process_ZFraction_ZFraction(diz, fr, proc, extOrder_frac, ops_frac), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_extOrder_hist_act, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_write, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_action, zfrac_val(extOrder_frac))
  ensures diz.Future_extOrder_hist_value == diz.Future_extOrder_hist_act
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures acc(diz.Future_ops_hist_act, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_write, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_action, zfrac_val(ops_frac))
  ensures diz.Future_ops_hist_value == diz.Future_ops_hist_act
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
{
  inhale false
}

method Future_commitOk_commit_Fraction_Process_ZFraction_ZFraction_Integer(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, ops_frac: zfrac, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_commitOk_Fraction_Process_ZFraction_ZFraction(diz, fr, proc, extOrder_frac, ops_frac), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires zfrac_val(extOrder_frac) != none
  requires acc(diz.Future_extOrder_hist_act, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_write, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_action, zfrac_val(extOrder_frac))
  requires zfrac_val(ops_frac) != none
  requires acc(diz.Future_ops_hist_act, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_write, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_action, zfrac_val(ops_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_committed()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_hist, zfrac_val(extOrder_frac))
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_hist, zfrac_val(ops_frac))
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
{
  inhale false
}

method Future_cancel_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_cancel(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_cancel_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_cancel_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_cancel_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_cancelPending()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_abort_begin_Fraction_Process_ZFraction_ZFraction_Integer(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, ops_frac: zfrac, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_abort(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires zfrac_val(extOrder_frac) != none
  requires acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_hist, zfrac_val(extOrder_frac))
  requires zfrac_val(ops_frac) != none
  requires acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_hist, zfrac_val(ops_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_beginPending() || diz.Future_status_hist_value[tid] == Status_opPending() || diz.Future_status_hist_value[tid] == Status_commitPending() || diz.Future_status_hist_value[tid] == Status_cancelPending()
  requires |diz.Future_status_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires |diz.Future_ops_hist_value| == TMS1_NUM_TRANSACTIONS()
  requires Future_validFail_Integer(diz, tid)
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_abort_Fraction_Process_ZFraction_ZFraction(diz, fr, proc, extOrder_frac, ops_frac), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_extOrder_hist_act, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_write, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_action, zfrac_val(extOrder_frac))
  ensures diz.Future_extOrder_hist_value == diz.Future_extOrder_hist_act
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures acc(diz.Future_ops_hist_act, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_write, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_action, zfrac_val(ops_frac))
  ensures diz.Future_ops_hist_value == diz.Future_ops_hist_act
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
{
  inhale false
}

method Future_abort_commit_Fraction_Process_ZFraction_ZFraction_Integer(diz: Ref, fr: frac, proc: Process, extOrder_frac: zfrac, ops_frac: zfrac, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_abort_Fraction_Process_ZFraction_ZFraction(diz, fr, proc, extOrder_frac, ops_frac), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires zfrac_val(extOrder_frac) != none
  requires acc(diz.Future_extOrder_hist_act, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_write, zfrac_val(extOrder_frac))
  requires acc(diz.Future_extOrder_hist_action, zfrac_val(extOrder_frac))
  requires zfrac_val(ops_frac) != none
  requires acc(diz.Future_ops_hist_act, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_write, zfrac_val(ops_frac))
  requires acc(diz.Future_ops_hist_action, zfrac_val(ops_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_aborted()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_extOrder_hist_value, zfrac_val(extOrder_frac))
  ensures acc(diz.Future_extOrder_hist_hist, zfrac_val(extOrder_frac))
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures acc(diz.Future_ops_hist_value, zfrac_val(ops_frac))
  ensures acc(diz.Future_ops_hist_hist, zfrac_val(ops_frac))
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
{
  inhale false
}

method Future_hist_set_extOrder_Set$Tuple$Integer_Integer$$(diz: Ref, value: Set[VCTTuple[Int, Int]])
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, write)
  requires acc(diz.Future_extOrder_hist_write, write)
  ensures acc(diz.Future_extOrder_hist_value, write) && diz.Future_extOrder_hist_value == value
  ensures acc(diz.Future_extOrder_hist_write, write)
{
  inhale false
}

method Future_hist_set_status_Sequence$Integer$(diz: Ref, value: Seq[Int])
  requires diz != null
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_value, write) && diz.Future_status_hist_value == value
  ensures acc(diz.Future_status_hist_write, write)
{
  inhale false
}

method Future_hist_set_ops_Sequence$Sequence$Tuple$Integer_Integer$$$(diz: Ref, value: Seq[Seq[VCTTuple[Int, Int]]])
  requires diz != null
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_value, write) && diz.Future_ops_hist_value == value
  ensures acc(diz.Future_ops_hist_write, write)
{
  inhale false
}

method Future_hist_set_invokedCommit_Sequence$Boolean$(diz: Ref, value: Seq[Bool])
  requires diz != null
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_value, write) && diz.Future_invokedCommit_hist_value == value
  ensures acc(diz.Future_invokedCommit_hist_write, write)
{
  inhale false
}

method Future_hist_set_pendingOp_Sequence$Integer$(diz: Ref, value: Seq[Int])
  requires diz != null
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_write, write)
  ensures acc(diz.Future_pendingOp_hist_value, write) && diz.Future_pendingOp_hist_value == value
  ensures acc(diz.Future_pendingOp_hist_write, write)
{
  inhale false
}

method Future_end_future(diz: Ref)
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, write)
  requires acc(diz.Future_extOrder_hist_hist, write)
  requires acc(diz.Future_extOrder_hist_init, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires acc(diz.Future_status_hist_init, write)
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_hist, write)
  requires acc(diz.Future_ops_hist_init, write)
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_hist, write)
  requires acc(diz.Future_invokedCommit_hist_init, write)
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_hist, write)
  requires acc(diz.Future_pendingOp_hist_init, write)
  requires acc(Future_hist_idle_Fraction_Process(diz, new_frac(write), p_empty()), write)
  ensures acc(diz.Future_extOrder_hist_value, write)
  ensures acc(diz.Future_extOrder_hist_write, write)
  ensures acc(diz.Future_extOrder_hist_free, write)
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_init)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_free, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_init)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_free, write)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_init)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_free, write)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_init)
  ensures acc(diz.Future_pendingOp_hist_value, write)
  ensures acc(diz.Future_pendingOp_hist_write, write)
  ensures acc(diz.Future_pendingOp_hist_free, write)
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_init)
{
  inhale false
}

method Future_split_Fraction_Process_Fraction_Process(diz: Ref, frac1: frac, proc1: Process, frac2: frac, proc2: Process)
  requires diz != null
  requires frac_val(frac1) + frac_val(frac2) <= write
  requires acc(Future_hist_idle_Fraction_Process(diz, new_frac(frac_val(frac1) + frac_val(frac2)), p_merge(proc1, proc2)), write)
  ensures acc(Future_hist_idle_Fraction_Process(diz, frac1, proc1), write)
  ensures acc(Future_hist_idle_Fraction_Process(diz, frac2, proc2), write)
{
  inhale false
}

method Future_merge_Fraction_Process_Fraction_Process(diz: Ref, frac1: frac, proc1: Process, frac2: frac, proc2: Process)
  requires diz != null
  requires frac_val(frac1) + frac_val(frac2) <= write
  requires acc(Future_hist_idle_Fraction_Process(diz, frac1, proc1), write)
  requires acc(Future_hist_idle_Fraction_Process(diz, frac2, proc2), write)
  ensures acc(Future_hist_idle_Fraction_Process(diz, new_frac(frac_val(frac1) + frac_val(frac2)), p_merge(proc1, proc2)), write)
{
  inhale false
}