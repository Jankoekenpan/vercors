// Generated on 2021-04-14 at 16:11:33
domain Process {
  
  function p_is_choice(p1: Process, p2: Process): Bool
  
  function p_empty(): Process
  
  function p_merge(p1: Process, p2: Process): Process
  
  function p_choice(p1: Process, p2: Process): Process
  
  function p_seq(p1: Process, p2: Process): Process
  
  function p_init(i: Int): Process
  
  function p_begin(tid: Int): Process
  
  function p_beginOk(tid: Int): Process
  
  function p_inv(tid: Int, invOp: Int): Process
  
  function p_resp(tid: Int, respOp: Int): Process
  
  function p_commit(tid: Int): Process
  
  function p_commitOk(tid: Int): Process
  
  function p_cancel(tid: Int): Process
  
  function p_abort(tid: Int): Process
  
  axiom empty_1L {
    (forall p: Process :: { p_merge(p_empty(), p) } p_merge(p_empty(), p) == p)
  }
  
  axiom empty_2L {
    (forall p: Process :: { p_seq(p_empty(), p) } p_seq(p_empty(), p) == p)
  }
  
  axiom empty_2R {
    (forall p: Process :: { p_seq(p, p_empty()) } p_seq(p, p_empty()) == p)
  }
  
  axiom choice_L {
    (forall p1: Process, p2: Process :: { p_is_choice(p_choice(p1, p2), p1) } p_is_choice(p_choice(p1, p2), p1))
  }
  
  axiom choice_R {
    (forall p1: Process, p2: Process :: { p_is_choice(p_choice(p1, p2), p2) } p_is_choice(p_choice(p1, p2), p2))
  }
  
  axiom choice_dist {
    (forall p1: Process, p2: Process, p3: Process :: { p_seq(p_choice(p1, p2), p3) } p_seq(p_choice(p1, p2), p3) == p_choice(p_seq(p1, p3), p_seq(p2, p3)))
  }
  
  axiom seq_assoc {
    (forall p1: Process, p2: Process, p3: Process :: { p_seq(p_seq(p1, p2), p3) } p_seq(p_seq(p1, p2), p3) == p_seq(p1, p_seq(p2, p3)))
  }
  
  axiom init_def_2 {
    (forall p: Process, i: Int :: { p_seq(p, p_init(i)) } p_seq(p, p_init(i)) == p_seq(p, p_seq(p_init(i), p_empty())))
  }
  
  axiom begin_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_begin(tid)) } p_seq(p, p_begin(tid)) == p_seq(p, p_seq(p_begin(tid), p_empty())))
  }
  
  axiom beginOk_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_beginOk(tid)) } p_seq(p, p_beginOk(tid)) == p_seq(p, p_seq(p_beginOk(tid), p_empty())))
  }
  
  axiom inv_def_2 {
    (forall p: Process, tid: Int, invOp: Int :: { p_seq(p, p_inv(tid, invOp)) } p_seq(p, p_inv(tid, invOp)) == p_seq(p, p_seq(p_inv(tid, invOp), p_empty())))
  }
  
  axiom resp_def_2 {
    (forall p: Process, tid: Int, respOp: Int :: { p_seq(p, p_resp(tid, respOp)) } p_seq(p, p_resp(tid, respOp)) == p_seq(p, p_seq(p_resp(tid, respOp), p_empty())))
  }
  
  axiom commit_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_commit(tid)) } p_seq(p, p_commit(tid)) == p_seq(p, p_seq(p_commit(tid), p_empty())))
  }
  
  axiom commitOk_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_commitOk(tid)) } p_seq(p, p_commitOk(tid)) == p_seq(p, p_seq(p_commitOk(tid), p_empty())))
  }
  
  axiom cancel_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_cancel(tid)) } p_seq(p, p_cancel(tid)) == p_seq(p, p_seq(p_cancel(tid), p_empty())))
  }
  
  axiom abort_def_2 {
    (forall p: Process, tid: Int :: { p_seq(p, p_abort(tid)) } p_seq(p, p_abort(tid)) == p_seq(p, p_seq(p_abort(tid), p_empty())))
  }
}

domain TYPE {
  
  unique function class_Future(): TYPE
  
  unique function class_java_DOT_lang_DOT_Object(): TYPE
  
  unique function class_Utils(): TYPE
  
  unique function class_Status(): TYPE
  
  unique function class_TMS1(): TYPE
  
  unique function class_EncodedGlobalVariables(): TYPE
  
  function directSuperclass(t: TYPE): TYPE
  
  function type_of(val: Ref): TYPE
  
  axiom Future_directSuperclass {
    directSuperclass(class_Future()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom Utils_directSuperclass {
    directSuperclass(class_Utils()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom Status_directSuperclass {
    directSuperclass(class_Status()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom TMS1_directSuperclass {
    directSuperclass(class_TMS1()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom EncodedGlobalVariables_directSuperclass {
    directSuperclass(class_EncodedGlobalVariables()) == class_java_DOT_lang_DOT_Object()
  }
}

domain frac {
  
  function frac_val(a: frac): Perm
  
  axiom frac_eq {
    (forall a: frac, b: frac :: { frac_val(a),frac_val(b) } (frac_val(a) == frac_val(b)) == (a == b))
  }
  
  axiom frac_bound {
    (forall a: frac :: { frac_val(a) } 0 / 1 < frac_val(a) && frac_val(a) <= 1 / 1)
  }
}

domain zfrac {
  
  function zfrac_val(a: zfrac): Perm
  
  axiom zfrac_eq {
    (forall a: zfrac, b: zfrac :: { zfrac_val(a),zfrac_val(b) } (zfrac_val(a) == zfrac_val(b)) == (a == b))
  }
  
  axiom zfrac_bound {
    (forall a: zfrac :: { zfrac_val(a) } 0 / 1 <= zfrac_val(a) && zfrac_val(a) <= 1 / 1)
  }
}

domain VCTTuple[F, S] {
  
  function vcttuple_tuple(f: F, s: S): VCTTuple[F, S]
  
  function vcttuple_fst(t: VCTTuple[F, S]): F
  
  function vcttuple_snd(t: VCTTuple[F, S]): S
  
  axiom vctTupleFstAx {
    (forall f1: F, s1: S :: { (vcttuple_fst((vcttuple_tuple(f1, s1): VCTTuple[F, S])): F) } (vcttuple_fst((vcttuple_tuple(f1, s1): VCTTuple[F, S])): F) == f1)
  }
  
  axiom vctTupleSndAx {
    (forall f1: F, s1: S :: { (vcttuple_snd((vcttuple_tuple(f1, s1): VCTTuple[F, S])): S) } (vcttuple_snd((vcttuple_tuple(f1, s1): VCTTuple[F, S])): S) == s1)
  }
}

//  a field 
field Future_extOrder_hist_value: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_init: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_act: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_write: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_free: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_hist: Set[VCTTuple[Int, Int]]

//  a field 
field Future_extOrder_hist_action: Set[VCTTuple[Int, Int]]

//  a field 
field Future_status_hist_value: Seq[Int]

//  a field 
field Future_status_hist_init: Seq[Int]

//  a field 
field Future_status_hist_act: Seq[Int]

//  a field 
field Future_status_hist_write: Seq[Int]

//  a field 
field Future_status_hist_free: Seq[Int]

//  a field 
field Future_status_hist_hist: Seq[Int]

//  a field 
field Future_status_hist_action: Seq[Int]

//  a field 
field Future_ops_hist_value: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_init: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_act: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_write: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_free: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_hist: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_ops_hist_action: Seq[Seq[VCTTuple[Int, Int]]]

//  a field 
field Future_invokedCommit_hist_value: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_init: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_act: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_write: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_free: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_hist: Seq[Bool]

//  a field 
field Future_invokedCommit_hist_action: Seq[Bool]

//  a field 
field Future_pendingOp_hist_value: Seq[Int]

//  a field 
field Future_pendingOp_hist_init: Seq[Int]

//  a field 
field Future_pendingOp_hist_act: Seq[Int]

//  a field 
field Future_pendingOp_hist_write: Seq[Int]

//  a field 
field Future_pendingOp_hist_free: Seq[Int]

//  a field 
field Future_pendingOp_hist_hist: Seq[Int]

//  a field 
field Future_pendingOp_hist_action: Seq[Int]

function Future_validCommit_Integer(diz: Ref, tid: Int): Bool
  requires diz != null
{
  true
}

function Future_validFail_Integer(diz: Ref, tid: Int): Bool
  requires diz != null
{
  true
}

function Future_validResp_Integer_Integer_Integer(diz: Ref, tid: Int, pendingOp: Int, respOp: Int): Bool
  requires diz != null
{
  true
}

function Utils_append_Sequence$Integer$_Integer(list: Seq[Int], item: Int): Seq[Int]
{
  list ++ Seq(item)
}

function Utils_append_Sequence$Tuple$Integer_Integer$$_Tuple$Integer_Integer$(list: Seq[VCTTuple[Int, Int]], item: VCTTuple[Int, Int]): Seq[VCTTuple[Int, Int]]
{
  list ++ Seq(item)
}

function Utils_concat_Sequence$Integer$_Sequence$Integer$(list1: Seq[Int], list2: Seq[Int]): Seq[Int]
{
  list1 ++ list2
}

function Utils_concat_Sequence$Tuple$Integer_Integer$$_Sequence$Tuple$Integer_Integer$$(list1: Seq[VCTTuple[Int, Int]], list2: Seq[VCTTuple[Int, Int]]): Seq[VCTTuple[Int, Int]]
{
  list1 ++ list2
}

function Status_notStarted(): Int
{
  0
}

function Status_beginPending(): Int
{
  1
}

function Status_ready(): Int
{
  2
}

function Status_opPending(): Int
{
  3
}

function Status_commitPending(): Int
{
  4
}

function Status_cancelPending(): Int
{
  5
}

function Status_committed(): Int
{
  6
}

function Status_aborted(): Int
{
  7
}

function TMS1_NUM_TRANSACTIONS(): Int
{
  10
}

function instanceof_TYPE_TYPE(t: TYPE, u: TYPE): Bool
  ensures result == (t == u || directSuperclass(t) == u)


function new_frac(x: Perm): frac
  requires 0 / 1 < x && x <= 1 / 1
  ensures frac_val(result) == x


function new_zfrac(x: Perm): zfrac
  requires 0 / 1 <= x && x <= 1 / 1
  ensures zfrac_val(result) == x


predicate Future_hist_do_init_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_begin_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_beginOk_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_inv_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_resp_Fraction_Process_ZFraction(diz: Ref, fr: frac, proc: Process, pendingOp_frac: zfrac) 

predicate Future_hist_do_commit_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_commitOk_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_cancel_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_do_abort_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

predicate Future_hist_idle_Fraction_Process(diz: Ref, fr: frac, proc: Process) 

method Future_init_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, i: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_init(i), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires write != none
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_hist, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_hist, write)
  requires 0 <= i
  requires i < |diz.Future_status_hist_value|
  requires i < |diz.Future_ops_hist_value|
  requires i < |diz.Future_invokedCommit_hist_value|
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_init_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_act, write)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_action, write)
  ensures diz.Future_ops_hist_value == diz.Future_ops_hist_act
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_act, write)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_action, write)
  ensures diz.Future_invokedCommit_hist_value == diz.Future_invokedCommit_hist_act
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_init_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, i: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_init_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires write != none
  requires acc(diz.Future_ops_hist_act, write)
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_write, write)
  requires acc(diz.Future_ops_hist_action, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_act, write)
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_write, write)
  requires acc(diz.Future_invokedCommit_hist_action, write)
  requires 0 <= i
  requires i < |diz.Future_status_hist_value|
  requires i < |diz.Future_ops_hist_value|
  requires i < |diz.Future_invokedCommit_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_ops_hist_act| == |diz.Future_ops_hist_value|
  requires |diz.Future_invokedCommit_hist_act| == |diz.Future_invokedCommit_hist_value|
  requires diz.Future_status_hist_value[i] == Status_notStarted()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != i ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires diz.Future_ops_hist_value[i] == Seq[VCTTuple[Int, Int]]()
  requires (forall x: Int :: { diz.Future_ops_hist_act[x] } { diz.Future_ops_hist_value[x] } 0 <= x && x < |diz.Future_ops_hist_value| && x != i ==> diz.Future_ops_hist_act[x] == diz.Future_ops_hist_value[x])
  requires diz.Future_invokedCommit_hist_value[i] == false
  requires (forall x: Int :: { diz.Future_invokedCommit_hist_act[x] } { diz.Future_invokedCommit_hist_value[x] } 0 <= x && x < |diz.Future_invokedCommit_hist_value| && x != i ==> diz.Future_invokedCommit_hist_act[x] == diz.Future_invokedCommit_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_hist, write)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_hist, write)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_begin_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_begin(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_notStarted()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_begin_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_begin_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_begin_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_beginPending()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_beginOk_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_beginOk(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_beginPending()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_beginOk_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_beginOk_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_beginOk_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_inv_begin_Fraction_Process_Integer_Integer(diz: Ref, fr: frac, proc: Process, tid: Int, invOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_inv(tid, invOp), proc)), write)
  requires write != none
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_hist, write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_inv_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_pendingOp_hist_act, write)
  ensures acc(diz.Future_pendingOp_hist_value, write)
  ensures acc(diz.Future_pendingOp_hist_write, write)
  ensures acc(diz.Future_pendingOp_hist_action, write)
  ensures diz.Future_pendingOp_hist_value == diz.Future_pendingOp_hist_act
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_inv_commit_Fraction_Process_Integer_Integer(diz: Ref, fr: frac, proc: Process, tid: Int, invOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_inv_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_pendingOp_hist_act, write)
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_write, write)
  requires acc(diz.Future_pendingOp_hist_action, write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_pendingOp_hist_act| == |diz.Future_pendingOp_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_opPending()
  requires diz.Future_pendingOp_hist_value[tid] == invOp
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires (forall x: Int :: { diz.Future_pendingOp_hist_act[x] } { diz.Future_pendingOp_hist_value[x] } 0 <= x && x < |diz.Future_pendingOp_hist_value| && x != tid ==> diz.Future_pendingOp_hist_act[x] == diz.Future_pendingOp_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_pendingOp_hist_value, write)
  ensures acc(diz.Future_pendingOp_hist_hist, write)
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_resp_begin_Fraction_Process_ZFraction_Integer_Integer(diz: Ref, fr: frac, proc: Process, pendingOp_frac: zfrac, tid: Int, respOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_resp(tid, respOp), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires write != none
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_hist, write)
  requires zfrac_val(pendingOp_frac) != none
  requires acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_hist, zfrac_val(pendingOp_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_ops_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires Future_validResp_Integer_Integer_Integer(diz, tid, diz.Future_pendingOp_hist_value[tid], respOp)
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_resp_Fraction_Process_ZFraction(diz, fr, proc, pendingOp_frac), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_act, write)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_action, write)
  ensures diz.Future_ops_hist_value == diz.Future_ops_hist_act
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_pendingOp_hist_act, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_write, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_action, zfrac_val(pendingOp_frac))
  ensures diz.Future_pendingOp_hist_value == diz.Future_pendingOp_hist_act
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
{
  inhale false
}

method Future_resp_commit_Fraction_Process_ZFraction_Integer_Integer(diz: Ref, fr: frac, proc: Process, pendingOp_frac: zfrac, tid: Int, respOp: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_resp_Fraction_Process_ZFraction(diz, fr, proc, pendingOp_frac), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires write != none
  requires acc(diz.Future_ops_hist_act, write)
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_write, write)
  requires acc(diz.Future_ops_hist_action, write)
  requires zfrac_val(pendingOp_frac) != none
  requires acc(diz.Future_pendingOp_hist_act, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_write, zfrac_val(pendingOp_frac))
  requires acc(diz.Future_pendingOp_hist_action, zfrac_val(pendingOp_frac))
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_ops_hist_value|
  requires tid < |diz.Future_pendingOp_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_ops_hist_act| == |diz.Future_ops_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  requires diz.Future_ops_hist_value[tid] == Utils_append_Sequence$Tuple$Integer_Integer$$_Tuple$Integer_Integer$(diz.Future_ops_hist_act[tid], (vcttuple_tuple(diz.Future_pendingOp_hist_value[tid], respOp): VCTTuple[Int, Int]))
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires (forall x: Int :: { diz.Future_ops_hist_act[x] } { diz.Future_ops_hist_value[x] } 0 <= x && x < |diz.Future_ops_hist_value| && x != tid ==> diz.Future_ops_hist_act[x] == diz.Future_ops_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_hist, write)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures acc(diz.Future_pendingOp_hist_value, zfrac_val(pendingOp_frac))
  ensures acc(diz.Future_pendingOp_hist_hist, zfrac_val(pendingOp_frac))
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
{
  inhale false
}

method Future_commit_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_commit(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_invokedCommit_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_commit_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_act, write)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_action, write)
  ensures diz.Future_invokedCommit_hist_value == diz.Future_invokedCommit_hist_act
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_commit_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_commit_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires write != none
  requires acc(diz.Future_invokedCommit_hist_act, write)
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_write, write)
  requires acc(diz.Future_invokedCommit_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires tid < |diz.Future_invokedCommit_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires |diz.Future_invokedCommit_hist_act| == |diz.Future_invokedCommit_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_commitPending()
  requires diz.Future_invokedCommit_hist_value[tid] == true
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  requires (forall x: Int :: { diz.Future_invokedCommit_hist_act[x] } { diz.Future_invokedCommit_hist_value[x] } 0 <= x && x < |diz.Future_invokedCommit_hist_value| && x != tid ==> diz.Future_invokedCommit_hist_act[x] == diz.Future_invokedCommit_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_hist, write)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
{
  inhale false
}

method Future_commitOk_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_commitOk(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_commitPending()
  requires Future_validCommit_Integer(diz, tid)
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_commitOk_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_commitOk_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_commitOk_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_committed()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_cancel_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_cancel(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_ready()
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_cancel_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_cancel_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_cancel_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_cancelPending()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_abort_begin_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_idle_Fraction_Process(diz, fr, p_seq(p_abort(tid), proc)), write)
  requires write != none
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_beginPending() || diz.Future_status_hist_value[tid] == Status_opPending() || diz.Future_status_hist_value[tid] == Status_commitPending() || diz.Future_status_hist_value[tid] == Status_cancelPending()
  requires Future_validFail_Integer(diz, tid)
  ensures frac_val(fr) != none
  ensures acc(Future_hist_do_abort_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_act, write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_action, write)
  ensures diz.Future_status_hist_value == diz.Future_status_hist_act
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_abort_commit_Fraction_Process_Integer(diz: Ref, fr: frac, proc: Process, tid: Int)
  requires diz != null
  requires frac_val(fr) != none
  requires acc(Future_hist_do_abort_Fraction_Process(diz, fr, proc), write)
  requires write != none
  requires acc(diz.Future_status_hist_act, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  requires acc(diz.Future_status_hist_action, write)
  requires 0 <= tid
  requires tid < |diz.Future_status_hist_value|
  requires |diz.Future_status_hist_act| == |diz.Future_status_hist_value|
  requires diz.Future_status_hist_value[tid] == Status_aborted()
  requires (forall x: Int :: { diz.Future_status_hist_act[x] } { diz.Future_status_hist_value[x] } 0 <= x && x < |diz.Future_status_hist_value| && x != tid ==> diz.Future_status_hist_act[x] == diz.Future_status_hist_value[x])
  ensures frac_val(fr) != none
  ensures acc(Future_hist_idle_Fraction_Process(diz, fr, proc), write)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_hist, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
{
  inhale false
}

method Future_hist_set_extOrder_Set$Tuple$Integer_Integer$$(diz: Ref, value: Set[VCTTuple[Int, Int]])
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, write)
  requires acc(diz.Future_extOrder_hist_write, write)
  ensures acc(diz.Future_extOrder_hist_value, write) && diz.Future_extOrder_hist_value == value
  ensures acc(diz.Future_extOrder_hist_write, write)
{
  inhale false
}

method Future_hist_set_status_Sequence$Integer$(diz: Ref, value: Seq[Int])
  requires diz != null
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_value, write) && diz.Future_status_hist_value == value
  ensures acc(diz.Future_status_hist_write, write)
{
  inhale false
}

method Future_hist_set_ops_Sequence$Sequence$Tuple$Integer_Integer$$$(diz: Ref, value: Seq[Seq[VCTTuple[Int, Int]]])
  requires diz != null
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_value, write) && diz.Future_ops_hist_value == value
  ensures acc(diz.Future_ops_hist_write, write)
{
  inhale false
}

method Future_hist_set_invokedCommit_Sequence$Boolean$(diz: Ref, value: Seq[Bool])
  requires diz != null
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_value, write) && diz.Future_invokedCommit_hist_value == value
  ensures acc(diz.Future_invokedCommit_hist_write, write)
{
  inhale false
}

method Future_hist_set_pendingOp_Sequence$Integer$(diz: Ref, value: Seq[Int])
  requires diz != null
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_write, write)
  ensures acc(diz.Future_pendingOp_hist_value, write) && diz.Future_pendingOp_hist_value == value
  ensures acc(diz.Future_pendingOp_hist_write, write)
{
  inhale false
}

method Future_end_future(diz: Ref)
  requires diz != null
  requires acc(diz.Future_extOrder_hist_value, write)
  requires acc(diz.Future_extOrder_hist_hist, write)
  requires acc(diz.Future_extOrder_hist_init, write)
  requires acc(diz.Future_status_hist_value, write)
  requires acc(diz.Future_status_hist_hist, write)
  requires acc(diz.Future_status_hist_init, write)
  requires acc(diz.Future_ops_hist_value, write)
  requires acc(diz.Future_ops_hist_hist, write)
  requires acc(diz.Future_ops_hist_init, write)
  requires acc(diz.Future_invokedCommit_hist_value, write)
  requires acc(diz.Future_invokedCommit_hist_hist, write)
  requires acc(diz.Future_invokedCommit_hist_init, write)
  requires acc(diz.Future_pendingOp_hist_value, write)
  requires acc(diz.Future_pendingOp_hist_hist, write)
  requires acc(diz.Future_pendingOp_hist_init, write)
  requires acc(Future_hist_idle_Fraction_Process(diz, new_frac(write), p_empty()), write)
  ensures acc(diz.Future_extOrder_hist_value, write)
  ensures acc(diz.Future_extOrder_hist_write, write)
  ensures acc(diz.Future_extOrder_hist_free, write)
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_value)
  ensures diz.Future_extOrder_hist_value == old(diz.Future_extOrder_hist_init)
  ensures acc(diz.Future_status_hist_value, write)
  ensures acc(diz.Future_status_hist_write, write)
  ensures acc(diz.Future_status_hist_free, write)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_value)
  ensures diz.Future_status_hist_value == old(diz.Future_status_hist_init)
  ensures acc(diz.Future_ops_hist_value, write)
  ensures acc(diz.Future_ops_hist_write, write)
  ensures acc(diz.Future_ops_hist_free, write)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_value)
  ensures diz.Future_ops_hist_value == old(diz.Future_ops_hist_init)
  ensures acc(diz.Future_invokedCommit_hist_value, write)
  ensures acc(diz.Future_invokedCommit_hist_write, write)
  ensures acc(diz.Future_invokedCommit_hist_free, write)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_value)
  ensures diz.Future_invokedCommit_hist_value == old(diz.Future_invokedCommit_hist_init)
  ensures acc(diz.Future_pendingOp_hist_value, write)
  ensures acc(diz.Future_pendingOp_hist_write, write)
  ensures acc(diz.Future_pendingOp_hist_free, write)
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_value)
  ensures diz.Future_pendingOp_hist_value == old(diz.Future_pendingOp_hist_init)
{
  inhale false
}

method Future_split_Fraction_Process_Fraction_Process(diz: Ref, frac1: frac, proc1: Process, frac2: frac, proc2: Process)
  requires diz != null
  requires frac_val(frac1) + frac_val(frac2) <= write
  requires acc(Future_hist_idle_Fraction_Process(diz, new_frac(frac_val(frac1) + frac_val(frac2)), p_merge(proc1, proc2)), write)
  ensures acc(Future_hist_idle_Fraction_Process(diz, frac1, proc1), write)
  ensures acc(Future_hist_idle_Fraction_Process(diz, frac2, proc2), write)
{
  inhale false
}

method Future_merge_Fraction_Process_Fraction_Process(diz: Ref, frac1: frac, proc1: Process, frac2: frac, proc2: Process)
  requires diz != null
  requires frac_val(frac1) + frac_val(frac2) <= write
  requires acc(Future_hist_idle_Fraction_Process(diz, frac1, proc1), write)
  requires acc(Future_hist_idle_Fraction_Process(diz, frac2, proc2), write)
  ensures acc(Future_hist_idle_Fraction_Process(diz, new_frac(frac_val(frac1) + frac_val(frac2)), p_merge(proc1, proc2)), write)
{
  inhale false
}