class Utils {

    static pure seq<int/*T*/> append(seq<int/*T*/> list, int/*T*/ item) = list ++ item;
    static pure seq<tuple<int, int>> append(seq<tuple<int, int>> list, tuple<int, int> item) = list ++ item;            //if PVL had generic support I wouldn't have to implement this twice.
    static pure seq<int/*T*/> concat(seq<int/*T*/> list1, seq<int/*T*/> list2) = list1 + list2;
    static pure seq<tuple<int, int>> concat(seq<tuple<int, int>> list1, seq<tuple<int, int>> list2) = list1 + list2;    //idem
    //why implement append and concat? because I'd rather use alphabetic names than symbolic names!
    //especially because PVL diverts from Haskell's and Scala's convention to use the double plus for concatenation!

//    ensures \result == (\exists int i; 0 <= i && i < |sequence|; sequence[i] == element);
//    static pure boolean elem(int element, seq<int> sequence) =
//        |sequence| == 0
//            ? false
//            : ((head(sequence) == element) || elem(element, tail(sequence)));

//    requires length >= 0;
//    ensures |\result| == length;
//    ensures (\forall int i; 0 <= i && i < length; \result[i] == i);
//    static pure seq<int> makeSeq(int length) = makeSeqHelper(0, length);
//
//    requires length >= 0;
//    ensures |\result| == length;
//    ensures (\forall int i; 0 <= i && i < |\result|; \result[i] == start + i);
//    static pure seq<int> makeSeqHelper(int start, int length) =
//        length > 0
//            ? start :: makeSeqHelper(start + 1, length - 1)
//            : seq<int> { }
//            ;

}

class Status {

    static pure int notStarted() = 0;
    static pure int beginPending() = 1;
    static pure int ready() = 2;
    static pure int opPending() = 3;
    static pure int commitPending() = 4;
    static pure int cancelPending() = 5;
    static pure int committed() = 6;
    static pure int aborted() = 7;

}

class Operation {

    //TODO contract must ensure that these encode-functions NEVER return a value that could possibly be returned by any of the other encode-functions
    //TODO contract must also ensure that their return values are 'unique' (can never yield the same answer with different inputs)

    static pure int encodeInvokeWrite(int tid, int address, int value) = 0 + 4 * (0+3*tid + 1+3*address + 2+3*value);
    static pure int encodeInvokeRead(int tid, int address) = 1 + 4 * (0+3*tid + 1+3*address);
    static pure int encodeRespRead(int tid, int address, int value) = 2 + 4 * (0+3*tid + 1+3*address + 2+3*value);
    static pure int encodeRespWrite(int tid, int address) = 3 + 4 * (0+3*tid + 1+3*address);

}

class TMS1 {

    static pure int NUM_TRANSACTIONS() = 10;

    //
    // Helper functions for derived state variables.
    // Unfortunately these are necessary because VerCors' implementation of set comprehensions is buggy.
    //
    //

    context |statuses| == NUM_TRANSACTIONS();
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (statuses[i] == Status.committed() || statuses[i] == Status.aborted()) ==> (i in \result) );
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (statuses[i] != Status.committed() && statuses[i] != Status.aborted()) ==> (!(i in \result)) );
    static pure set<int> doneTransactions(seq<int> statuses) = doneTransactionsHelper(0, statuses);

    context |statuses| == NUM_TRANSACTIONS() - currentIndex;
    ensures |\result| <= |statuses|;
    ensures (\forall int i; i in \result; currentIndex <= i && i < currentIndex + |statuses|);
    ensures (\forall int i; 0 <= i && i < |statuses|; (statuses[i] == Status.committed() || statuses[i] == Status.aborted()) ==> ((currentIndex + i) in \result) );
    ensures (\forall int i; 0 <= i && i < |statuses|; (statuses[i] != Status.committed() && statuses[i] != Status.aborted()) ==> (!((currentIndex + i) in \result)) );
    static pure set<int> doneTransactionsHelper(int currentIndex, seq<int> statuses) =
        |statuses| == 0
            ? set<int> { }
            : ((head(statuses) == Status.committed() || head(statuses) == Status.aborted())
                ? set<int> { currentIndex }
                : set<int> { } )
                + doneTransactionsHelper(currentIndex + 1, tail(statuses));

    context |statuses| == NUM_TRANSACTIONS();
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (statuses[i] == Status.committed()) ==> (i in \result) );
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (statuses[i] != Status.committed()) ==> (!(i in \result)) );
    static pure set<int> committedTransactions(seq<int> statuses) = committedTransactionsHelper(0, statuses);

    context |statuses| == NUM_TRANSACTIONS() - currentIndex;
    ensures |\result| <= |statuses|;
    ensures (\forall int i; i in \result; currentIndex <= i && i < currentIndex + |statuses|);
    ensures (\forall int i; 0 <= i && i < |statuses|; (statuses[i] == Status.committed()) ==> ((currentIndex + i) in \result) );
    ensures (\forall int i; 0 <= i && i < |statuses|; (statuses[i] != Status.committed()) ==> (!((currentIndex + i) in \result)) );
    static pure set<int> committedTransactionsHelper(int currentIndex, seq<int> statuses) =
        |statuses| == 0
            ? set<int> { }
            : ((head(statuses) == Status.committed())
                ? set<int> { currentIndex }
                : set<int> { } )
                + committedTransactionsHelper(currentIndex + 1, tail(statuses));

    context |statuses| == NUM_TRANSACTIONS();
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (statuses[i] == Status.commitPending()) ==> (i in \result) );
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (statuses[i] != Status.commitPending()) ==> (!(i in \result)) );
    static pure set<int> commitPendingTransactions(seq<int> statuses) = commitPendingTransactionsHelper(0, statuses);

    context |statuses| == NUM_TRANSACTIONS() - currentIndex;
    ensures |\result| <= |statuses|;
    ensures (\forall int i; i in \result; currentIndex <= i && i < currentIndex + |statuses|);
    ensures (\forall int i; 0 <= i && i < |statuses|; (statuses[i] == Status.commitPending()) ==> ((currentIndex + i) in \result) );
    ensures (\forall int i; 0 <= i && i < |statuses|; (statuses[i] != Status.commitPending()) ==> (!((currentIndex + i) in \result)) );
    static pure set<int> commitPendingTransactionsHelper(int currentIndex, seq<int> statuses) =
        |statuses| == 0
            ? set<int> { }
            : ((head(statuses) == Status.commitPending())
                ? set<int> { currentIndex }
                : set<int> { } )
                + commitPendingTransactionsHelper(currentIndex + 1, tail(statuses));

    context |invokedCommits| == NUM_TRANSACTIONS();
    ensures (\forall int i; i in \result; 0 <= i && i < NUM_TRANSACTIONS());
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); invokedCommits[i] ==> (i in \result) );
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (!invokedCommits[i]) ==> (!(i in \result)) );
    static pure set<int> invokedCommitTransactions(seq<boolean> invokedCommits) = invokedCommitTransactionsHelper(0, invokedCommits);

    context |invokedCommits| == NUM_TRANSACTIONS() - currentIndex;
    ensures |\result| <= |invokedCommits|;
    ensures (\forall int i; i in \result; currentIndex <= i && i < currentIndex + |invokedCommits|);
    ensures (\forall int i; 0 <= i && i < |invokedCommits|; invokedCommits[i] ==> ((currentIndex + i) in \result) );
    ensures (\forall int i; 0 <= i && i < |invokedCommits|; (!invokedCommits[i]) ==> (!((currentIndex + i) in \result)) );
    static pure set<int> invokedCommitTransactionsHelper(int currentIndex, seq<boolean> invokedCommits) =
        |invokedCommits| == 0
            ? set<int> { }
            : ((head(invokedCommits))
                ? set<int> { currentIndex }
                : set <int> { } )
                + invokedCommitTransactionsHelper(currentIndex + 1, tail(invokedCommits));

    //
    // Checks for serializations of transactions.
    //
    //

    //static pure set<seq<int>> serializations(set<int> transactions, set<tuple<int, int>> externalOrder) =
    //    set<seq<int>> { sequenz | seq<int> sequenz;                                         //sequenz will be contrained such that it is a permutation.
    //        |sequenz| == |transactions| &&                                                  //lengths are equal
    //        (\forall int i; 0 <= i && i < |sequenz|; sequenz[i] in transactions) &&         //all elements in the sequence are also in the set of transactions
    //        (\forall int i; 0 <= i && i < |sequenz|; (\forall int j; 0 <= j && j < |sequenz| && j != i; sequenz[i] != sequenz[j])) &&   //all elements are unique
    //        respectsOrder(sequenz, externalOrder) };                                        //order is satisfied
    //this does not work due to an half-working implementation of set-comprehensions in VerCors.
    //so instead we work around it by making it abstract, and have the contract specify the behaviour.

    ensures (\forall seq<int> sequenz; sequenz in \result; |sequenz| == |transactions| &&
            (\forall int i; 0 <= i && i < |sequenz|; sequenz[i] in transactions) &&
            (\forall int i; 0 <= i && i < |sequenz|; (\forall int j; 0 <= j && j < |sequenz| && j != i; sequenz[i] != sequenz[j]) ) &&
            respectsOrder(sequenz, externalOrder)
            );
    static pure set<seq<int>> serializations(set<int> transactions, set<tuple<int, int>> externalOrder);

    //TODO what contract do I need here? do I need one in the first place?
    static pure boolean respectsOrder(seq<int> transactionIds, set<tuple<int, int>> order) =
        (\forall int index; 0 <= index && index < (|transactionIds|-1); inOrder(transactionIds[index], transactionIds[index+1], order));

    //TODO what contract doI need here? do I need one in the first place?
    //TODO alles wat 'links' light van 'right' komt niet meer voor in 'order'
    //TODO order mag geen cikels bevatten!
    static pure boolean inOrder(int left, int right, set<tuple<int, int>> order) =
        (tuple<int, int> { left, right } in order) ||
        (\exists int newRight; newRight in rightValues(left, order); inOrder(newRight, right, order));

    ensures (\forall int i; i in \result; 0 <= i && i < NUM_TRANSACTIONS());
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (tuple<int, int> { leftValue, i } in relation) ==> (i in \result) );
    ensures (\forall int i; 0 <= i && i < NUM_TRANSACTIONS(); (!(tuple<int, int> { leftValue, i } in relation)) ==> (!(i in \result)) );
    static pure set<int> rightValues(int leftValue, set<tuple<int, int>> relation) =
        rightValuesBounded(0, NUM_TRANSACTIONS(), leftValue, relation);
        //set<int> { rightValue | int rightValue <- {0..(NUM_TRANSACTIONS()-1)} ; tuple<int, int> { leftValue, rightValue } in relation };
        //set<int> { getSnd(tup) | tuple<int, int> tup <- relation; getFst(tup) == leftValue };

    requires 0 <= lowerBoundIncl;
    requires lowerBoundIncl <= upperBoundExcl;
    ensures (\forall int i; i in \result; lowerBoundIncl <= i && i < upperBoundExcl);
    ensures (\forall int i; lowerBoundIncl <= i && i < upperBoundExcl; (tuple<int, int> { leftValue, i } in relation) ==> (i in \result) );
    ensures (\forall int i; lowerBoundIncl <= i && i < upperBoundExcl; (!(tuple<int, int> { leftValue, i } in relation)) ==> (!(i in \result)) );
    static pure set<int> rightValuesBounded(int lowerBoundIncl, int upperBoundExcl, int leftValue, set<tuple<int, int>> relation) =
        lowerBoundIncl == upperBoundExcl
            ? set<int> { }
            : (tuple<int, int> { leftValue, lowerBoundIncl } in relation
                ? set<int> { lowerBoundIncl }
                : set<int> { }
              ) + rightValuesBounded(lowerBoundIncl + 1, upperBoundExcl, leftValue, relation);

}

/**
 *  This class models the 'TMS1' I/O automaton, as described in
 *  "Towards formally specifying and verifying transactional memory"
 *  by Simon Doherty, Lindsay Groves, Victor Luchangco and Mark Moir.
 *
 *  @see <a href=https://doi.org/10.1007/s00165-012-0225-8>Towards formally specifying and verifying transactional memory</a>
 *  @author Jan Boerman
 */
class `Future` {
    /*
    The general gist of things is that that there is a 'global' relation of transactions
    which defines a partial order in which the transactions can occur.
    The left element of a pair in the relation 'happens before' the right element of that pair.

    Because VerCors requires that processes reside in a class called Future, we model transactions not using a separate Transaction class,
    but instead we use sequences for all the properties of a transaction such that 'seq(index)' refers to the property of transaction labeled with subscript 'index'

    All of this is actually a workaround for limitations in VerCors:
        - custom classes cannot be used in Futures.
        - processes can only reside in Futures.
        - 'dynamic dispatch' of processes in a process in another class/Future is therefore not possible right now.
    */

    // ========= Order of Transactions =========

    //the relation that defines the order between transactions.
    //the id of a transaction is used to index into the sequences defined below.
    set<tuple<int/*transaction id*/, int/*transaction id*/>> extOrder;


    // ========= Transaction state =========

    //the 'current' status of a transaction.
    //note that this is a sequence because this field models the statuses of all transactions.
    seq<int/*Status*/> status;

    //the list of operations of a transaction.
    //note that this is a sequence because this field models the operationss of all transactions.
    seq<seq<tuple<int/*InvOperation*/, int/*RespOperation*/>>> ops;

    //whether the commit transition has been taken.
    //note that this is a sequence because this field models the invokedCommit status of all transactions.
    seq<boolean> invokedCommit;

    //the last operation that is being tested whether it is allowed or not.
    //note that this is a sequence because this field models the pendingOps of all transactions.
    seq<int/*InvOperation*/> pendingOp;


    // ========= Derived state variables, functions and predicates =========

    // derived state

    accessible status;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (status[tid] == Status.committed() || status[tid] == Status.aborted()) ==> (tid in \result) );
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (status[tid] != Status.committed() && status[tid] != Status.aborted()) ==> (!(tid in \result)) );
    pure set<int> doneTransactions() =
        TMS1.doneTransactions(status);
        //set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; (status[i] == Status.committed()) || (status[i] == Status.aborted()) };

    accessible status;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (status[tid] == Status.committed()) ==> (tid in \result) );
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (status[tid] != Status.committed()) ==> (!(tid in \result)) );
    pure set<int> committedTransactions() =
        TMS1.committedTransactions(status);
        //set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; status[i] == Status.committed() };

    accessible status;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (status[tid] == Status.commitPending()) ==> (tid in \result) );
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (status[tid] != Status.commitPending()) ==> (!(tid in \result)) );
    pure set<int> commitPendingTransactions() =
        TMS1.commitPendingTransactions(status);
        //set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; status[i] == Status.commitPending() };

    accessible invokedCommit;
    requires |invokedCommit| == TMS1.NUM_TRANSACTIONS();
    ensures (\forall int tid; tid in \result; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS());
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); invokedCommit[tid] ==> (tid in \result) );
    ensures (\forall int tid; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS(); (!invokedCommit[tid]) ==> (!(tid in \result)) );
    pure set<int> invokedCommitTransactions() =
        TMS1.invokedCommitTransactions(invokedCommit);
        //set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; invokedCommit[i] };


    // functions

    //this is called 'ops(sigma)' in the paper, but we're calling it allOps to prevent name collisions.
    accessible ops;
    requires (\forall int i; 0 <= i && i < |serialization|; 0 <= serialization[i] && serialization[i] < |ops|);
    pure seq<tuple<int, int>> allOps(seq<int> serialization/*the ints here are the transaction ids*/) =
        |serialization| == 0
            ? seq<tuple<int, int>> { }
            : (ops[head(serialization)] + allOps(tail(serialization)));
    //TODO add a good ensures clause here


    //all possible serializations of the transactions that respect the given order
    //e.g. in Scala it would be something like this: transactions.permutations.filter(sequence => respects(order, sequence))
    ensures (\forall seq<int> sequenz; sequenz in \result; |sequenz| == |transactions| &&
                (\forall int i; 0 <= i && i < |sequenz|; sequenz[i] in transactions) &&
                (\forall int i; 0 <= i && i < |sequenz|; (\forall int j; 0 <= j && j < |sequenz| && j != i; sequenz[i] != sequenz[j]) ) &&
                TMS1.respectsOrder(sequenz, order)
            );
    pure set<seq<int>> ser(set<int> transactions, set<tuple<int, int>> order) =
        TMS1.serializations(transactions, order);


    // predicates

    pure boolean legal(seq<tuple<int, int>> invRespOps) = true;
        //TODO if I want to implement this properly, then I need better types than int to model InvOps and RespOps
        //TODO can I abuse bit-properties of ints to make this work?

    //extConsPrefix
    accessible extOrder;
    accessible status;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    requires (\forall int tid; tid in serialization; 0 <= tid && tid < TMS1.NUM_TRANSACTIONS());
    pure boolean extConsPrefix(set<int> serialization/*the ints here are transaction ids*/) =
        (\forall int idOne; 0 <= idOne && idOne < TMS1.NUM_TRANSACTIONS();
            (\forall int idTwo; 0 <= idTwo && idTwo < TMS1.NUM_TRANSACTIONS();
                (idTwo in serialization) &&
                (TMS1.inOrder(idOne, idTwo, extOrder) ==>
                    ( (idOne in serialization) == (status[idOne] == Status.committed()) )
                )
            )
        );
        //TODO good ensures clause?

    //validCommit
    accessible extOrder;
    accessible status;
    accessible ops;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    requires |ops| == TMS1.NUM_TRANSACTIONS();
    pure boolean validCommit(int tid) =
        (\exists set<int> S; S <= commitPendingTransactions();
            (\exists seq<int> serialization; serialization in ser(committedTransactions() + S, extOrder);
                (tid in S) && legal(allOps(serialization))
            )
        );

    //validFail
    accessible extOrder;
    accessible status;
    accessible ops;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    requires |ops| == TMS1.NUM_TRANSACTIONS();
    pure boolean validFail(int tid) =
        (\exists set<int> S; S <= commitPendingTransactions();
            (\exists seq<int> serialization; serialization in ser(committedTransactions() + S, extOrder);
                (!(tid in S)) && legal(allOps(serialization))
            )
        );

    //validResp
    accessible extOrder;
    accessible invokedCommit;
    accessible ops;
    requires |invokedCommit| == TMS1.NUM_TRANSACTIONS();
    requires |ops| == TMS1.NUM_TRANSACTIONS();
    requires 0 <= tid && tid < TMS1.NUM_TRANSACTIONS();
    accessible status;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    pure boolean validResp(int tid, int pendingOp, int respOp) =
        (\exists set<int> S; S <= invokedCommitTransactions();
            (\exists seq<int> serialization; serialization in ser(S, extOrder);
                extConsPrefix(S + set<int> { tid }) && legal(allOps(serialization ++ tid) ++ tuple<int, int>{pendingOp, respOp})
            )
        );
        //TODO good ensures clause?


    // ========= Processes =========

    //TODO read invokes, write responses
    process total(int tid) = init(tid) * begin(tid) * afterBeginPending(tid);
    process afterBeginPending(int tid) = abort(tid) + (beginOk(tid) * (afterReady(tid)));
    process afterReady(int tid) = (cancel(tid) * abort(tid))
        + (inv(tid, 0) * ((resp(tid, 0) * afterReady(tid)) + abort(tid)))
        + (commit(tid) * afterCommitPending(tid));
    process afterCommitPending(int tid) = abort (tid) + commitOk(tid);


    //init
    context 0 <= i;
    context i < |status|;
    context i < |ops|;
    context i < |invokedCommit|;
    modifies status;
    modifies ops;
    modifies invokedCommit;
    ensures |\old(status)| == |status|;
    ensures |\old(ops)| == |ops|;
    ensures |\old(invokedCommit)| == |invokedCommit|;
    ensures status[i] == Status.notStarted();
    ensures (\forall int x; 0 <= x && x < |status| && x != i; \old(status[x]) == status[x]);
    ensures ops[i] == seq<tuple<int/*InvOperation*/, int/*RespOperation*/>> { };
    ensures (\forall int x; 0 <= x && x < |ops| && x != i; \old(ops[x]) == ops[x]);
    ensures invokedCommit[i] == false;
    ensures (\forall int x; 0 <= x && x < |invokedCommit| && x != i; \old(invokedCommit[x]) == invokedCommit[x]);
    process init(int i);

    //begin
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.notStarted();
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.beginPending();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status)[x] == status[x]);
    process begin(int tid);

    //beginOk
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.beginPending();
    ensures status[tid] == Status.ready();
    process beginOk(int tid);

    //inv
    context 0 <= tid;
    context tid < |status|;
    context tid < |pendingOp|;
    modifies status;
    modifies pendingOp;
    requires status[tid] == Status.ready();
    ensures |\old(status)| == |status|;
    ensures |\old(pendingOp)| == |pendingOp|;
    ensures status[tid] == Status.opPending();
    ensures pendingOp[tid] == invOp;
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    ensures (\forall int x; 0 <= x && x < |pendingOp| && x != tid; \old(pendingOp[x]) == pendingOp[x]);
    process inv(int tid, int invOp);

    //resp
    context 0 <= tid;
    context tid < |status|;
    context tid < |ops|;
    context tid < |pendingOp|;
    accessible pendingOp;
    modifies status;
    modifies ops;
    //requirements for validResp:
    accessible extOrder;
    accessible invokedCommit;
    requires |invokedCommit| == TMS1.NUM_TRANSACTIONS();
    requires |ops| == TMS1.NUM_TRANSACTIONS();
    requires |status| == TMS1.NUM_TRANSACTIONS();
    requires validResp(tid, this.pendingOp[tid], respOp);
    ensures |\old(status)| == |status|;
    ensures |\old(ops)| == |ops|;
    ensures status[tid] == Status.ready();
    ensures ops[tid] == Utils.append(\old(ops[tid]), tuple<int, int> {pendingOp[tid], respOp});
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    ensures (\forall int x; 0 <= x && x < |ops| && x != tid; \old(ops[x]) == ops[x]);
    process resp(int tid, int respOp);

    //commit
    context 0 <= tid;
    context tid < |status|;
    context tid < |invokedCommit|;
    modifies status;
    modifies invokedCommit;
    requires status[tid] == Status.ready();
    ensures |\old(status)| == |status|;
    ensures |\old(invokedCommit)| == |invokedCommit|;
    ensures status[tid] == Status.commitPending();
    ensures invokedCommit[tid] == true;
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    ensures (\forall int x; 0 <= x && x < |invokedCommit| && x != tid; \old(invokedCommit[x]) == invokedCommit[x]);
    process commit(int tid);

    //commitOk
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.commitPending();
    //requirements for validCommit:
    accessible extOrder;
    accessible ops;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    requires |ops| == TMS1.NUM_TRANSACTIONS();
    requires validCommit(tid);
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.committed();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    process commitOk(int tid);

    //cancel
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.ready();
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.cancelPending();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    process cancel(int tid);

    //abort
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires (status[tid] == Status.beginPending()) ||
            (status[tid] == Status.opPending()) ||
            (status[tid] == Status.commitPending()) ||
            (status[tid] == Status.cancelPending());
    //requirements for validFail:
    accessible extOrder;
    accessible ops;
    requires |status| == TMS1.NUM_TRANSACTIONS();
    requires |ops| == TMS1.NUM_TRANSACTIONS();
    requires validFail(tid);
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.aborted();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    process abort(int tid);

}
