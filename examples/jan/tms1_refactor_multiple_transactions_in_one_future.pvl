class Utils {

    static pure seq<int/*T*/> append(seq<int/*T*/> list, int/*T*/ item) = list ++ item;
    static pure seq<tuple<int, int>> append(seq<tuple<int, int>> list, tuple<int, int> item) = list ++ item;            //if PVL had generic support I wouldn't have to implement this twice.
    static pure seq<int/*T*/> concat(seq<int/*T*/> list1, seq<int/*T*/> list2) = list1 + list2;
    static pure seq<tuple<int, int>> concat(seq<tuple<int, int>> list1, seq<tuple<int, int>> list2) = list1 + list2;    //idem
    //why implement append and concat? because I'd rather use alphabetic names than symbolic names!
    //especially because PVL diverts from Haskell's and Scala's convention to use the double plus for concatenation!

}

class Status {

    static pure int notStarted() = 0;
    static pure int beginPending() = 1;
    static pure int ready() = 2;
    static pure int opPending() = 3;
    static pure int commitPending() = 4;
    static pure int cancelPending() = 5;
    static pure int committed() = 6;
    static pure int aborted() = 7;

}

class TMS1 {

    static pure int NUM_TRANSACTIONS() = 10;

}

/**
 *  This class models the 'TMS1' I/O automaton, as described in
 *  "Towards formally specifying and verifying transactional memory"
 *  by Simon Doherty, Lindsay Groves, Victor Luchangco and Mark Moir.
 *
 *  @see <a href=https://doi.org/10.1007/s00165-012-0225-8>Towards formally specifying and verifying transactional memory</a>
 *  @author Jan Boerman
 */
class `Future` {
    /*
    The general gist of things is that that there is a 'global' relation of transactions
    which defines a partial order in which the transactions can occur.
    The left element of a pair in the relation 'happens before' the right element of that pair.

    Because VerCors requires that processes reside in a class called Future, we model transactions not using a separate Transaction class,
    but instead we use sequences for all the properties of a transaction such that 'seq(index)' refers to the property of transaction labeled with subscript 'index'

    All of this is actually a workaround for limitations in VerCors:
        - custom classes cannot be used in Futures.
        - processes can only reside in Futures.
        - 'dynamic dispatch' of processes in a process in another class/Future is therefore not possible right now.
    */

    // ========= Order of Transactions =========

    //the relation that defines the order between transactions.
    //the id of a transaction is used to index into the sequences defined below.
    set<tuple<int/*transaction id*/, int/*transaction id*/>> extOrder;


    // ========= Transaction state =========

    //the 'current' status of a transaction.
    //note that this is a sequence because this field models the statuses of all transactions.
    seq<int/*Status*/> status;

    //the list of operations of a transaction.
    //note that this is a sequence because this field models the operationss of all transactions.
    seq<seq<tuple<int/*InvOperation*/, int/*RespOperation*/>>> ops;

    //whether the commit transition has been taken.
    //note that this is a sequence because this field models the invokedCommit status of all transactions.
    seq<boolean> invokedCommit;

    //the last operation that is being tested whether it is allowed or not.
    //note that this is a sequence because this field models the pendingOps of all transactions.
    seq<int/*InvOperation*/> pendingOp;

    // ========= Derived state variables, functions and predicates =========

    //TODO fix that VerCors actually correctly translates these functions!
    //TODO suggested locations where to fix this: SilverClassReduction, CheckHistoryAlgebra, AddTypeADT (encodeInheritanceToDomain)

    //TODO actually implement these predicates
    //TODO define 'ser' and 'legal'

    // derived state

    accessible status;
    ensures (\forall int tid; tid in \result; (status[tid] == Status.committed()) || (status[tid] == Status.aborted()));
    ensures (\forall int tid; !(tid in \result); (status[tid] != Status.committed()) && (status[tid] != Status.aborted()));
    pure set<int> doneTransactions() =
        set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; (status[i] == Status.committed()) || (status[i] == Status.aborted()) };
//    pure set<int> committedTransactions() =
//        set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; status[i] == Status.committed() };
//    pure set<int> commitPendingTransactions() =
//        set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; status[i] == Status.commitPending() };
//    pure set<int> invokedCommitTransactions() =
//        set<int> { i | int i <- {0..(TMS1.NUM_TRANSACTIONS()-1)}; invokedCommit[i] };
//
//
//    // functions
//
//    //this is called 'ops(sigma)' in the paper, but we're calling it allOps to prevent name collisions.
//    pure seq<tuple<int, int>> allOps(seq<int> serialization/*the ints here are the transaction ids*/) =
//        Utils.concat(ops[head(serialization)], allOps(tail(serialization)));
//
//    pure set<seq<int>> ser(set<int> transactions, set<tuple<int, int>> order) =
//        set<seq<int>> {};
//        //TODO all possible serializations of the transactions, respecting the given order
//        //TODO transactions.permutations().filter(sequence -> respects(order, sequence))
//
//
//    // predicates
//    pure boolean legal(seq<tuple<int, int>> invRespOps) = true;
//        //TODO if I want to implement this properly, then I need better types than int to model InvOps and RespOps
//        //TODO can I abuse bit-properties of ints to make this work?
//
//    pure boolean extConsPrefix(seq<int> serialization/*the ints here are transaction ids*/) =
//        (\forall int idOne; idOne <= 0 && idOne < TMS1.NUM_TRANSACTIONS();
//            (\forall int idTwo; idTwo <= 0 && idTwo < TMS1.NUM_TRANSACTIONS();
//                (idTwo in serialization) &&
//                ((tuple<int, int> {idOne, idTwo} in extOrder) ==>
//                    ((idOne in serialization) == (status[idOne] == Status.committed()))
//                )
//            )
//        );

    pure boolean validCommit(int tid) = true;
        /*
        (\exists set<int> S; S <= commitPendingTransactions();
            (\exists seq<int> serialization; serialization in ser(committedTransactions() + S, extOrder);
                (tid in S) && legal(allOps(serialization))
            )
        );
        */
    pure boolean validFail(int tid) = true;
        /*
        (\exists set<int> S; S <= commitPendingTransactions();
            (\exists seq<int> serialization; serialization in ser(committedTransactions() + S, extOrder);
                (!(tid in S)) && legal(allOps(serialization))
            )
        );
        */
    pure boolean validResp(int tid, int pendingOp, int respOp) = true;
        /*
        (\exists set<int> S; S <= invokedCommitTransactions();
            (\exists seq<int> serialization; serialization in ser(S, extOrder);
                extConsPrefix(S + set<int> { tid }) && legal(allOps(serialization ++ tid) ++ tuple<int, int>{pendingOp, respOp})
            )
        );
        */


    // ========= Processes =========

    //TODO combine these processes into one 'total' process.

    //init
    context 0 <= i;
    context i < |status|;
    context i < |ops|;
    context i < |invokedCommit|;
    modifies status;
    modifies ops;
    modifies invokedCommit;
    ensures |\old(status)| == |status|;
    ensures |\old(ops)| == |ops|;
    ensures |\old(invokedCommit)| == |invokedCommit|;
    ensures status[i] == Status.notStarted();
    ensures (\forall int x; 0 <= x && x < |status| && x != i; \old(status[x]) == status[x]);
    ensures ops[i] == seq<tuple<int/*InvOperation*/, int/*RespOperation*/>> { };
    ensures (\forall int x; 0 <= x && x < |ops| && x != i; \old(ops[x]) == ops[x]);
    ensures invokedCommit[i] == false;
    ensures (\forall int x; 0 <= x && x < |invokedCommit| && x != i; \old(invokedCommit[x]) == invokedCommit[x]);
    process init(int i);

    //begin
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.notStarted();
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.beginPending();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status)[x] == status[x]);
    process begin(int tid);

    //beginOk
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.beginPending();
    ensures status[tid] == Status.ready();
    process beginOk(int tid);

    //inv
    context 0 <= tid;
    context tid < |status|;
    context tid < |pendingOp|;
    modifies status;
    modifies pendingOp;
    requires status[tid] == Status.ready();
    ensures |\old(status)| == |status|;
    ensures |\old(pendingOp)| == |pendingOp|;
    ensures status[tid] == Status.opPending();
    ensures pendingOp[tid] == invOp;
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    ensures (\forall int x; 0 <= x && x < |pendingOp| && x != tid; \old(pendingOp[x]) == pendingOp[x]);
    process inv(int tid, int invOp);

    //resp
    context 0 <= tid;
    context tid < |status|;
    context tid < |ops|;
    context tid < |pendingOp|;
    accessible pendingOp;
    modifies status;
    modifies ops;
    requires this.validResp(tid, this.pendingOp[tid], respOp);
    ensures |\old(status)| == |status|;
    ensures |\old(ops)| == |ops|;
    ensures status[tid] == Status.ready();
    ensures ops[tid] == Utils.append(\old(ops[tid]), tuple<int, int> {pendingOp[tid], respOp});
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    ensures (\forall int x; 0 <= x && x < |ops| && x != tid; \old(ops[x]) == ops[x]);
    process resp(int tid, int respOp);

    //commit
    context 0 <= tid;
    context tid < |status|;
    context tid < |invokedCommit|;
    modifies status;
    modifies invokedCommit;
    requires status[tid] == Status.ready();
    ensures |\old(status)| == |status|;
    ensures |\old(invokedCommit)| == |invokedCommit|;
    ensures status[tid] == Status.commitPending();
    ensures invokedCommit[tid] == true;
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    ensures (\forall int x; 0 <= x && x < |invokedCommit| && x != tid; \old(invokedCommit[x]) == invokedCommit[x]);
    process commit(int tid);

    //commitOk
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.commitPending();
    requires validCommit(tid);
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.committed();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    process commitOk(int tid);

    //cancel
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires status[tid] == Status.ready();
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.cancelPending();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    process cancel(int tid);

    //abort
    context 0 <= tid;
    context tid < |status|;
    modifies status;
    requires (status[tid] == Status.beginPending()) ||
            (status[tid] == Status.opPending()) ||
            (status[tid] == Status.commitPending()) ||
            (status[tid] == Status.cancelPending());
    requires validFail(tid);
    ensures |\old(status)| == |status|;
    ensures status[tid] == Status.aborted();
    ensures (\forall int x; 0 <= x && x < |status| && x != tid; \old(status[x]) == status[x]);
    process abort(int tid);


}
